{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Previous Next NetDEM is a neural network enabled C++ library for discrete element methods. Features It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc. News Date Message Apr 2023 Intelligent NetDEM code searching using chatGPT and embedding. Dec 2022 Fully resolved CFD-DEM, with unresolved, semi-resolved, resovled and hybrid solvers. Jun 2022 Integrated with OpenFOAM for a resolved CFD-DEM. Dec 2021 Exposed most APIs to python via pybind11, added python examples. Sep 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Documentation Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . License & citation NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"Home"},{"location":"#features","text":"It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc.","title":"Features"},{"location":"#news","text":"Date Message Apr 2023 Intelligent NetDEM code searching using chatGPT and embedding. Dec 2022 Fully resolved CFD-DEM, with unresolved, semi-resolved, resovled and hybrid solvers. Jun 2022 Integrated with OpenFOAM for a resolved CFD-DEM. Dec 2021 Exposed most APIs to python via pybind11, added python examples. Sep 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc.","title":"News"},{"location":"#documentation","text":"Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments .","title":"Contact"},{"location":"#license-citation","text":"NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"License &amp; citation"},{"location":"about/acknowledgement/","text":"How to cite We do not have a paper for this extire library for now. Please cite one of our relevant works with Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 1-21. Contributors We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem . Fundings This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020) Copyright & License Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Acknowledgements"},{"location":"about/acknowledgement/#_1","text":"","title":""},{"location":"about/acknowledgement/#how-to-cite","text":"We do not have a paper for this extire library for now. Please cite one of our relevant works with Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 1-21.","title":"How to cite"},{"location":"about/acknowledgement/#contributors","text":"We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem .","title":"Contributors"},{"location":"about/acknowledgement/#fundings","text":"This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020)","title":"Fundings"},{"location":"about/acknowledgement/#copyright-license","text":"Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Copyright &amp; License"},{"location":"about/help_%26_support/","text":"Help & support There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request . Contact Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Help & Support"},{"location":"about/help_%26_support/#_1","text":"","title":""},{"location":"about/help_%26_support/#help-support","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request .","title":"Help &amp; support"},{"location":"about/help_%26_support/#contact","text":"Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Contact"},{"location":"about/news_%26_updates/","text":"News 2021 Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment. Revision notes (As from Dec 11, 2021) v0.0 Implement light-weight FEM to model deformable particle Change raw array to std::vector, etc. Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"News & Updates"},{"location":"about/news_%26_updates/#_1","text":"","title":""},{"location":"about/news_%26_updates/#news","text":"","title":"News"},{"location":"about/news_%26_updates/#2021","text":"Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment.","title":"2021"},{"location":"about/news_%26_updates/#revision-notes","text":"(As from Dec 11, 2021)","title":"Revision notes"},{"location":"about/news_%26_updates/#v00","text":"Implement light-weight FEM to model deformable particle Change raw array to std::vector, etc. Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"v0.0"},{"location":"about/publications/","text":"Journal articles 2023 Huang, S., Huang, L., Lai, Z., & Zhao, J. (2023). Morphology characterization and discrete element modeling of coral sand with intraparticle voids . Engineering Geology, 315, 107023.. 2022 Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 70, 763\u2013783. 2021 Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Presentations and posters Seminar and invited talks","title":"Publications"},{"location":"about/publications/#_1","text":"","title":""},{"location":"about/publications/#journal-articles","text":"","title":"Journal articles"},{"location":"about/publications/#2023","text":"Huang, S., Huang, L., Lai, Z., & Zhao, J. (2023). Morphology characterization and discrete element modeling of coral sand with intraparticle voids . Engineering Geology, 315, 107023..","title":"2023"},{"location":"about/publications/#2022","text":"Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 70, 763\u2013783.","title":"2022"},{"location":"about/publications/#2021","text":"Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371.","title":"2021"},{"location":"about/publications/#presentations-and-posters","text":"","title":"Presentations and posters"},{"location":"about/publications/#seminar-and-invited-talks","text":"","title":"Seminar and invited talks"},{"location":"documentation/basic_usage/","text":"User manual \u250a Previous \u250a Next Run built-in examples There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example, and can be visualized in paraview . ./build/bin/netdem_example_random_packing python3 example/00_random_packing/pynetdem_1_gjk_solver.py Reconstruct mesh of particles and walls For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] [0, 1] Option [0, 1] is for importing shape informaiton, such that 0 indicates using the json shape info (i.e., shape_000_000000000000000.json), 1 indicates using stl shape files. For json shape info, please specify the exact file name for [shape_dir] , whereas the directory shape/ for stl shape info. or easier ./scripts/auto_mesh_particle.sh [out_dir] [0, 1, or 2] ./scripts/auto_mesh_wall.sh [out_dir] [0, 1, or 2] Option [0, 1, or 2] is for importing shape informaiton, such that 0 indicates using the 0-time-step shape info (i.e., shape_000_000000000000000.json) in the shape/ sub-directory of the result root, 1 indicates using STL shape files, whereas 2 indicates using time specific shape info (e.g., shape_000_0000000xxxxxxxxx.json). Customized simulation Please follow the built-in examples to write the c++ or python scripts. Visualize in paraview Results can be dumped as VTK files, which can be visualized in paraview . Spherical particles Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range . General particles and walls Reconstruc the mesh of particles and walls ; Import to praview; Contact force chain Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes. Ray tracing Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section. Create animation In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c. Post-process We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy). User manual \u250a Previous \u250a Next","title":"Basic usage"},{"location":"documentation/basic_usage/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/basic_usage/#run-built-in-examples","text":"There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example, and can be visualized in paraview . ./build/bin/netdem_example_random_packing python3 example/00_random_packing/pynetdem_1_gjk_solver.py","title":"Run built-in examples"},{"location":"documentation/basic_usage/#reconstruct-mesh-of-particles-and-walls","text":"For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] [0, 1] Option [0, 1] is for importing shape informaiton, such that 0 indicates using the json shape info (i.e., shape_000_000000000000000.json), 1 indicates using stl shape files. For json shape info, please specify the exact file name for [shape_dir] , whereas the directory shape/ for stl shape info. or easier ./scripts/auto_mesh_particle.sh [out_dir] [0, 1, or 2] ./scripts/auto_mesh_wall.sh [out_dir] [0, 1, or 2] Option [0, 1, or 2] is for importing shape informaiton, such that 0 indicates using the 0-time-step shape info (i.e., shape_000_000000000000000.json) in the shape/ sub-directory of the result root, 1 indicates using STL shape files, whereas 2 indicates using time specific shape info (e.g., shape_000_0000000xxxxxxxxx.json).","title":"Reconstruct mesh of particles and walls"},{"location":"documentation/basic_usage/#customized-simulation","text":"Please follow the built-in examples to write the c++ or python scripts.","title":"Customized simulation"},{"location":"documentation/basic_usage/#visualize-in-paraview","text":"Results can be dumped as VTK files, which can be visualized in paraview .","title":"Visualize in paraview"},{"location":"documentation/basic_usage/#spherical-particles","text":"Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range .","title":"Spherical particles"},{"location":"documentation/basic_usage/#general-particles-and-walls","text":"Reconstruc the mesh of particles and walls ; Import to praview;","title":"General particles and walls"},{"location":"documentation/basic_usage/#contact-force-chain","text":"Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes.","title":"Contact force chain"},{"location":"documentation/basic_usage/#ray-tracing","text":"Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section.","title":"Ray tracing"},{"location":"documentation/basic_usage/#create-animation","text":"In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c.","title":"Create animation"},{"location":"documentation/basic_usage/#post-process","text":"We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy). User manual \u250a Previous \u250a Next","title":"Post-process"},{"location":"documentation/blender_rendering/","text":"User manual \u250a Previous Rendering in blender Install blender and add-ons Install blender, which can be obtained from https://www.blender.org . Install VTK inside the blender python environment. Hint: to add vtk support in blender, please visit https://github.com/simboden/BVtkNodes/blob/master/build_vtk.md . Install BVtkNodes add-on, which can be obtained from https://github.com/tkeskita/BVtkNodes . Thanks Silvano Imboden (s.imboden@cineca.it), Lorenzo Celli, and Paul Mc Manus for the original work , and Tuomo Keskitalo for functionality extending and maintaining. Hint: to install add-on in blender: go to Edit \u2192 Preferences \u2192 add-on , and install the add-on by selecting the zip file downloaded from the github main/master branch. Rendering Switch to the BVTK Node Tree editor, and new a node tree similar to the following figure. Switch back to the 3D Viewport editor, and you should get a scene as following. Play with the VTK filters and blender feature to polish the scene (color represents the stress). Below is an animation of membrane pulling and twisting, where the result data is simulated and created in NetDEM . Hints: Shortkeys: ctrl + alt + NumPad 0 to set the camera to current view; G to translate the selected object; x to delete the selected object; ctrl or shift + mouse operalaitons to pan, zoom-in and zoom-out the view. Rendering settings: suggest to use cycles engine, with the Max Samples set to 10 . For rendering animaiton: the Time Selector filter will change the file name according to the index of frame. At current stage, the file names should indexed with sequential numbers, i.e., xx_000.vtk , xx_001.vtk , xx_999.vtk , etc. One can play with the vtk filters for possible entension. User manual \u250a Previous","title":"Blender rendering"},{"location":"documentation/blender_rendering/#_1","text":"User manual \u250a Previous","title":""},{"location":"documentation/blender_rendering/#rendering-in-blender","text":"","title":"Rendering in blender"},{"location":"documentation/blender_rendering/#install-blender-and-add-ons","text":"Install blender, which can be obtained from https://www.blender.org . Install VTK inside the blender python environment. Hint: to add vtk support in blender, please visit https://github.com/simboden/BVtkNodes/blob/master/build_vtk.md . Install BVtkNodes add-on, which can be obtained from https://github.com/tkeskita/BVtkNodes . Thanks Silvano Imboden (s.imboden@cineca.it), Lorenzo Celli, and Paul Mc Manus for the original work , and Tuomo Keskitalo for functionality extending and maintaining. Hint: to install add-on in blender: go to Edit \u2192 Preferences \u2192 add-on , and install the add-on by selecting the zip file downloaded from the github main/master branch.","title":"Install blender and add-ons"},{"location":"documentation/blender_rendering/#rendering","text":"Switch to the BVTK Node Tree editor, and new a node tree similar to the following figure. Switch back to the 3D Viewport editor, and you should get a scene as following. Play with the VTK filters and blender feature to polish the scene (color represents the stress). Below is an animation of membrane pulling and twisting, where the result data is simulated and created in NetDEM . Hints: Shortkeys: ctrl + alt + NumPad 0 to set the camera to current view; G to translate the selected object; x to delete the selected object; ctrl or shift + mouse operalaitons to pan, zoom-in and zoom-out the view. Rendering settings: suggest to use cycles engine, with the Max Samples set to 10 . For rendering animaiton: the Time Selector filter will change the file name according to the index of frame. At current stage, the file names should indexed with sequential numbers, i.e., xx_000.vtk , xx_001.vtk , xx_999.vtk , etc. One can play with the vtk filters for possible entension. User manual \u250a Previous","title":"Rendering"},{"location":"documentation/cfddem_simulation/","text":"User manual User manual for CFD-DEM simulation Installation Install prerequisites: the compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt-get install build-essential cmake sudo apt-get install libopenmpi-dev openmpi-bin zlib1g-dev libboost-all-dev sudo apt-get install flex bison gnuplot libreadline-dev libncurses-dev libxt-dev Install netdem from https://github.com/apaam . mkdir apaam cd apaam git clone https://github.com/apaam/netdem.git . cd netdem make cd .. Install openfoam from https://github.com/apaam . git clone https://github.com/apaam/openfoam_customized.git . cd openfoam_customized make cd .. Init OpenFOAM environment by adding the following lines to and sourcing the .bashrc (where $path_apaam is the path of apaam) export APAAM_DIR=$path_apaam export path_openfoam=$path_apaam/openfoam_customized/OpenFOAM-build alias openfoam_init='source $path_openfoam/etc/bashrc' openfoam_init echo \"using openfoam=$path_openfoam\" Install cfddem from https://github.com/apaam . git clone https://github.com/apaam/cfddem.git . cd cfddem make cd .. Add the library and binary directory to system PATH in .bashrc (where $path_apaam is the path of apaam) export PATH=$PATH:$path_apaam/cfddem/build/bin export PYTHONPATH=$path_apaam/netdem/build/lib Examples & tutorials Some preliminary examples are located under directory examples/ , which can be run with, e.g., (in the example directory) ./Allrun Note if the pynetdem package cannot be imported into python, one might need to exiplictly add the path (e.g., sys.path.append(\"/Users/lzhshou/Documents/Research/myProjects/apaam/repo/netdem/build/lib/\") ) of the netdem python library in createDEM.py . Run water entry example Copy the example folder to a local directory cd cfddem cp -rf examples/interIBdem/water_entry local/interIBdem/ Run the example Please note that system/fvSolution -> coupling specifies the DEM file and function that will be invoked for the coupling. cd local/interIBdem/water_entry ./Allclean ./Allrun-parallel In case the run fails, please check the lib path has been correctly set in createDEM.py , where the path is the directory of netdem libs. Paraview Rendering Render CFD results Open interIBdem.foam to paraview Change the properties Type Case to Decomposed Case and uncheck Skip Zero Time (optional) Play with the result fields Optinal: for viaulizeing interal filed results, one can use the Clip or Slice filter Optinal: to construct the interface of the water and air, one can add Contour filter to interIBdem.foam , set Contour by to alpha.water and change the contour value to 0.5 Render DEM results Open dem/particle_mesh_xxx.vtk.serries to paraview Optional: select all particle_mesh_xxx.vtk.serries and add a Group Datesets filter Optional: add a Caculator filter after the Group Datesets filter, set Result Array Name to U , and input formulation vel . This will add a U field to the particles, wihch can be linked with the CFD field U Optional: for probing the evolution of a property value with time, one can add a Plot Data Over Time filter to the Group Datesets , and change the Field Associates to Cells . Then, one can play with the property to show in the newly opened Line Chart View Modify the water entry parameters Fuild properties such as viscosity and density is specified in file constant/transportProperties . Please note that fuilds being used are speficied in phases . Geometries are determined by the system/blockMeshDict . Please note that when scale exist, the coordinates of the vertices with be multiplied by the scale when creating the real mesh. Mesh size are govened by the three values before simpleGrading in the blocks -> hex entry. It is suggested to use cubic elements. The inital volume fraction of the fuilds are specifed in system/setFiledsDict . Please not that the scale parameter in system/blockMeshDict will not work here, thus the vertices here are their exact values. Entry box (-0.05 -0.05 -0.15) (0.05 0.05 0.03) specifies the lower-left-front and upper-right-back coordicates of the box Please note that the field entry alpha.glycerol should be consistent with that specified in constant/transportProperties -> phases File system/controlDict specifies the simulation time, timestep and writing interval, etc. In createDEM.py -> oneSphere() funciton, one can modify the DEM domain geometries and particle properties. Please note that in the present funciton, the parameter scale varies the size of the DEM domain, wall box and particle intertion region, whereas the p_size is the exact value of particle diameter. User manual","title":"Cfddem simulation"},{"location":"documentation/cfddem_simulation/#_1","text":"User manual","title":""},{"location":"documentation/cfddem_simulation/#user-manual-for-cfd-dem-simulation","text":"","title":"User manual for CFD-DEM simulation"},{"location":"documentation/cfddem_simulation/#installation","text":"Install prerequisites: the compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt-get install build-essential cmake sudo apt-get install libopenmpi-dev openmpi-bin zlib1g-dev libboost-all-dev sudo apt-get install flex bison gnuplot libreadline-dev libncurses-dev libxt-dev Install netdem from https://github.com/apaam . mkdir apaam cd apaam git clone https://github.com/apaam/netdem.git . cd netdem make cd .. Install openfoam from https://github.com/apaam . git clone https://github.com/apaam/openfoam_customized.git . cd openfoam_customized make cd .. Init OpenFOAM environment by adding the following lines to and sourcing the .bashrc (where $path_apaam is the path of apaam) export APAAM_DIR=$path_apaam export path_openfoam=$path_apaam/openfoam_customized/OpenFOAM-build alias openfoam_init='source $path_openfoam/etc/bashrc' openfoam_init echo \"using openfoam=$path_openfoam\" Install cfddem from https://github.com/apaam . git clone https://github.com/apaam/cfddem.git . cd cfddem make cd .. Add the library and binary directory to system PATH in .bashrc (where $path_apaam is the path of apaam) export PATH=$PATH:$path_apaam/cfddem/build/bin export PYTHONPATH=$path_apaam/netdem/build/lib","title":"Installation"},{"location":"documentation/cfddem_simulation/#examples-tutorials","text":"Some preliminary examples are located under directory examples/ , which can be run with, e.g., (in the example directory) ./Allrun Note if the pynetdem package cannot be imported into python, one might need to exiplictly add the path (e.g., sys.path.append(\"/Users/lzhshou/Documents/Research/myProjects/apaam/repo/netdem/build/lib/\") ) of the netdem python library in createDEM.py .","title":"Examples &amp; tutorials"},{"location":"documentation/cfddem_simulation/#run-water-entry-example","text":"Copy the example folder to a local directory cd cfddem cp -rf examples/interIBdem/water_entry local/interIBdem/ Run the example Please note that system/fvSolution -> coupling specifies the DEM file and function that will be invoked for the coupling. cd local/interIBdem/water_entry ./Allclean ./Allrun-parallel In case the run fails, please check the lib path has been correctly set in createDEM.py , where the path is the directory of netdem libs.","title":"Run water entry example"},{"location":"documentation/cfddem_simulation/#paraview-rendering","text":"Render CFD results Open interIBdem.foam to paraview Change the properties Type Case to Decomposed Case and uncheck Skip Zero Time (optional) Play with the result fields Optinal: for viaulizeing interal filed results, one can use the Clip or Slice filter Optinal: to construct the interface of the water and air, one can add Contour filter to interIBdem.foam , set Contour by to alpha.water and change the contour value to 0.5 Render DEM results Open dem/particle_mesh_xxx.vtk.serries to paraview Optional: select all particle_mesh_xxx.vtk.serries and add a Group Datesets filter Optional: add a Caculator filter after the Group Datesets filter, set Result Array Name to U , and input formulation vel . This will add a U field to the particles, wihch can be linked with the CFD field U Optional: for probing the evolution of a property value with time, one can add a Plot Data Over Time filter to the Group Datesets , and change the Field Associates to Cells . Then, one can play with the property to show in the newly opened Line Chart View","title":"Paraview Rendering"},{"location":"documentation/cfddem_simulation/#modify-the-water-entry-parameters","text":"Fuild properties such as viscosity and density is specified in file constant/transportProperties . Please note that fuilds being used are speficied in phases . Geometries are determined by the system/blockMeshDict . Please note that when scale exist, the coordinates of the vertices with be multiplied by the scale when creating the real mesh. Mesh size are govened by the three values before simpleGrading in the blocks -> hex entry. It is suggested to use cubic elements. The inital volume fraction of the fuilds are specifed in system/setFiledsDict . Please not that the scale parameter in system/blockMeshDict will not work here, thus the vertices here are their exact values. Entry box (-0.05 -0.05 -0.15) (0.05 0.05 0.03) specifies the lower-left-front and upper-right-back coordicates of the box Please note that the field entry alpha.glycerol should be consistent with that specified in constant/transportProperties -> phases File system/controlDict specifies the simulation time, timestep and writing interval, etc. In createDEM.py -> oneSphere() funciton, one can modify the DEM domain geometries and particle properties. Please note that in the present funciton, the parameter scale varies the size of the DEM domain, wall box and particle intertion region, whereas the p_size is the exact value of particle diameter. User manual","title":"Modify the water entry parameters"},{"location":"documentation/dem_basics/","text":"DEM wiki \u250a Next [This page is part of Dr. Zhengshou Lai's dissertation .] This page presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation. Overview of DEM DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments. Key components of DEM Basic elements In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model. Contacts and contact models Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in . Newton-Euler equations of motion In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions. Time integration To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 . Critical timestep The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle. Computational workflow DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme. Particle representation There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method. Single-particle method The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems. Composite-particle method In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 ) Contact models A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section. Linear elastic model A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact. Rolling resistance model The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models. Hertz-Mindlin model The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} in which \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle. Linear parallel bond model The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively. Model calibration As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. DEM wiki \u250a Next References C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17(3):377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29(1):47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26(6):698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266(3):493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11(6):449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method (GEM): linking inter-particle forces with macroscopic loading. Granular Matter , 14(1):51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60(6):1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40(3):367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32(5):340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60(5):1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41(8):1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25(3):117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50(1):43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160(3):219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15(1):85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4(2):77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47(2):319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17(9):603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9(2):115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4(1):101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26(6):645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35(2):733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12(2):140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124(3):285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10(4):235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11(5):293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"Dem basics"},{"location":"documentation/dem_basics/#_1","text":"DEM wiki \u250a Next [This page is part of Dr. Zhengshou Lai's dissertation .] This page presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation.","title":""},{"location":"documentation/dem_basics/#overview-of-dem","text":"DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments.","title":"Overview of DEM"},{"location":"documentation/dem_basics/#key-components-of-dem","text":"","title":"Key components of DEM"},{"location":"documentation/dem_basics/#basic-elements","text":"In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model.","title":"Basic elements"},{"location":"documentation/dem_basics/#contacts-and-contact-models","text":"Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in .","title":"Contacts and contact models"},{"location":"documentation/dem_basics/#newton-euler-equations-of-motion","text":"In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions.","title":"Newton-Euler equations of motion"},{"location":"documentation/dem_basics/#time-integration","text":"To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 .","title":"Time integration"},{"location":"documentation/dem_basics/#critical-timestep","text":"The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle.","title":"Critical timestep"},{"location":"documentation/dem_basics/#computational-workflow","text":"DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme.","title":"Computational workflow"},{"location":"documentation/dem_basics/#particle-representation","text":"There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method.","title":"Particle representation"},{"location":"documentation/dem_basics/#single-particle-method","text":"The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems.","title":"Single-particle method"},{"location":"documentation/dem_basics/#composite-particle-method","text":"In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 )","title":"Composite-particle method"},{"location":"documentation/dem_basics/#contact-models","text":"A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section.","title":"Contact models"},{"location":"documentation/dem_basics/#linear-elastic-model","text":"A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact.","title":"Linear elastic model"},{"location":"documentation/dem_basics/#rolling-resistance-model","text":"The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models.","title":"Rolling resistance model"},{"location":"documentation/dem_basics/#hertz-mindlin-model","text":"The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} in which \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle.","title":"Hertz-Mindlin model"},{"location":"documentation/dem_basics/#linear-parallel-bond-model","text":"The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively.","title":"Linear parallel bond model"},{"location":"documentation/dem_basics/#model-calibration","text":"As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. DEM wiki \u250a Next","title":"Model calibration"},{"location":"documentation/dem_basics/#references","text":"C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17(3):377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29(1):47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26(6):698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266(3):493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11(6):449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method (GEM): linking inter-particle forces with macroscopic loading. Granular Matter , 14(1):51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60(6):1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40(3):367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32(5):340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60(5):1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41(8):1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25(3):117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50(1):43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160(3):219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15(1):85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4(2):77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47(2):319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17(9):603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9(2):115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4(1):101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26(6):645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35(2):733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12(2):140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124(3):285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10(4):235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11(5):293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"References"},{"location":"documentation/dem_wiki/","text":"DEM basics DEM basics : presents a brief introduction and review of the discrete element method (DEM). DEM elements Discrete to continuum : derives the macroscopic continuum-sense stress, strain and tangent moduli from the particle contact geometries and contact forces at microscopic discrete level. Particle models : describes the formulations of various particle models, including sphere, ellipsoid, poly-super-ellipsoid, poly-super-quadrics, cylinder, spherical harmonics, polyhedron, level set, and etc.","title":"DEM wiki"},{"location":"documentation/dem_wiki/#_1","text":"","title":""},{"location":"documentation/dem_wiki/#dem-basics","text":"DEM basics : presents a brief introduction and review of the discrete element method (DEM).","title":"DEM basics"},{"location":"documentation/dem_wiki/#dem-elements","text":"Discrete to continuum : derives the macroscopic continuum-sense stress, strain and tangent moduli from the particle contact geometries and contact forces at microscopic discrete level. Particle models : describes the formulations of various particle models, including sphere, ellipsoid, poly-super-ellipsoid, poly-super-quadrics, cylinder, spherical harmonics, polyhedron, level set, and etc.","title":"DEM elements"},{"location":"documentation/dev_pybind_styles/","text":"Conventions For each class, it is suggested to bind a Print method (if exists) to a python method __repr__ . For example pybind11::class_<Sphere>(m, \"Sphere\") .def(\"__repr__\", &Sphere::Print);","title":"Dev pybind styles"},{"location":"documentation/dev_pybind_styles/#_1","text":"","title":""},{"location":"documentation/dev_pybind_styles/#conventions","text":"For each class, it is suggested to bind a Print method (if exists) to a python method __repr__ . For example pybind11::class_<Sphere>(m, \"Sphere\") .def(\"__repr__\", &Sphere::Print);","title":"Conventions"},{"location":"documentation/developer_manual/","text":"Code design General framework The program currently contains 7 basic moduli: dem: ingradients of DEM, including DEM solver, contact solver, contact models, and etc. domain: defines the computational domain input: used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, modifier, etc. get: get object properties set: set object properties fix: Bind the defined modifier to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation modifier: defines some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the modifier is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed modifier will be called uniformly. Currently, two modifiers are defined: pre_modifier and post_modifier. pre_modifier is called at the beginning of each calculation cycle, and post_modifier is called at the end of each calculation cycle. mpi: data interaction between different parallel computing cores scene: contains particle, wall, contact model, modifier, etc. shape: defines the shape tmplates, including sphere, ellipsoid, cylinder, spherical harmonics, polyhedron, level set, and etc. utils: other tool functions Other moduli (as of Dec. 26, 2021): mlpack: wrapper of mlpack for machine learning exploration peridigm: wrapper of peridigm for particle breakage analysis pybind: for python interfaces Basic elements Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics Calculation procedures The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_modifier, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_modifier, such as data output and other functions. Coding style We generally follow Google C++ Style Guide . Naming Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Word following abbreviations shoudl be capitalized accordingly, e.g., GJKsolver, DEMgjk, GJKdemGJK, etc. Macros: should be capital, such as PI . Comment Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001 Formatting Use clang-format . Programing rules Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers . Performance evaluation Procedures Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Example performance counter stats: 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Developer manual"},{"location":"documentation/developer_manual/#_1","text":"","title":""},{"location":"documentation/developer_manual/#code-design","text":"","title":"Code design"},{"location":"documentation/developer_manual/#general-framework","text":"The program currently contains 7 basic moduli: dem: ingradients of DEM, including DEM solver, contact solver, contact models, and etc. domain: defines the computational domain input: used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, modifier, etc. get: get object properties set: set object properties fix: Bind the defined modifier to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation modifier: defines some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the modifier is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed modifier will be called uniformly. Currently, two modifiers are defined: pre_modifier and post_modifier. pre_modifier is called at the beginning of each calculation cycle, and post_modifier is called at the end of each calculation cycle. mpi: data interaction between different parallel computing cores scene: contains particle, wall, contact model, modifier, etc. shape: defines the shape tmplates, including sphere, ellipsoid, cylinder, spherical harmonics, polyhedron, level set, and etc. utils: other tool functions Other moduli (as of Dec. 26, 2021): mlpack: wrapper of mlpack for machine learning exploration peridigm: wrapper of peridigm for particle breakage analysis pybind: for python interfaces","title":"General framework"},{"location":"documentation/developer_manual/#basic-elements","text":"Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics","title":"Basic elements"},{"location":"documentation/developer_manual/#calculation-procedures","text":"The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_modifier, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_modifier, such as data output and other functions.","title":"Calculation procedures"},{"location":"documentation/developer_manual/#coding-style","text":"We generally follow Google C++ Style Guide .","title":"Coding style"},{"location":"documentation/developer_manual/#naming","text":"Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Word following abbreviations shoudl be capitalized accordingly, e.g., GJKsolver, DEMgjk, GJKdemGJK, etc. Macros: should be capital, such as PI .","title":"Naming"},{"location":"documentation/developer_manual/#comment","text":"Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001","title":"Comment"},{"location":"documentation/developer_manual/#formatting","text":"Use clang-format .","title":"Formatting"},{"location":"documentation/developer_manual/#programing-rules","text":"Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers .","title":"Programing rules"},{"location":"documentation/developer_manual/#performance-evaluation","text":"","title":"Performance evaluation"},{"location":"documentation/developer_manual/#procedures","text":"Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Example performance counter stats: 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Procedures"},{"location":"documentation/discrete_to_continuum/","text":"DEM wiki \u250a Previous [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.] \u5e94\u529b (Stress) \u57fa\u4e8e\u8fde\u7eed\u6027\u4ecb\u8d28\u7406\u8bba\uff0c\u6750\u6599\u7684\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u8868\u793a\u4e3a\uff08\u5ffd\u7565\u4f53\u529b\u53ca\u52a0\u901f\u5ea6\u9879\uff09 \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \u91c7\u7528\u7231\u56e0\u65af\u5766\u6c42\u548c\u7ea6\u5b9a\uff0c\u4e0a\u5f0f\u53ef\u5199\u4f5c \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \u5229\u7528\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u5f97\u7b49\u5f0f \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \u9488\u5bf9\u67d0\u4e2a\u9897\u7c92 p p \uff0c\u5176\u5185\u90e8\u5e94\u529b\u7684\u79ef\u5206\u53ef\u8ba1\u7b97\u4e3a \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \u5176\u4e2d\uff0c c c \u8868\u793a\u8be5\u9897\u7c92\u7684\u6240\u6709\u63a5\u89e6\u3001 f_j f_j \u8868\u793a\u63a5\u89e6\u529b\u3001 x_k x_k \u8868\u793a\u63a5\u89e6\u4f4d\u7f6e\u3002\u8fdb\u800c\uff0c\u5229\u7528\u9897\u7c92\u5728\u63a5\u89e6\u529b\u4f5c\u7528\u4e0b\u7684\u9759\u529b\u5e73\u8861\u516c\u5f0f \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \u53ef\u5f97 \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \u5176\u4e2d\uff0c x_k^p x_k^p \u4e3a\u9897\u7c92\u8d28\u5fc3\u3001 b_k b_k \u4e3a\u7531\u63a5\u89e6\u70b9\u6307\u5411\u9897\u7c92\u8d28\u5fc3\u7684\u5411\u91cf\uff08branch vector\uff09\u3002 \u9488\u5bf9\u4ee3\u8868\u5355\u5143\u4f53\uff0c\u5176\u57df\u5185\u7684\u5e73\u5747\u5e94\u529b\u53ef\u7531\u5176\u5185\u90e8\u6240\u6709\u9897\u7c92\u5185\u90e8\u7684\u5e94\u529b\u79ef\u5206\uff0c\u518d\u9664\u4e8e\u4ee3\u8868\u5355\u5143\u4f53\u4f53\u79ef\u5f97\u5230\uff0c\u8868\u8fbe\u4e3a \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \u5176\u4e2d\uff0c c c \u4e3a\u4ee3\u8868\u5355\u5143\u4f53\u5185\u7684\u6240\u6709\u63a5\u89e6\u3001 d_k d_k \u8868\u793a\u9897\u7c92\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf\u3002 \u5e94\u53d8 (Strain) \u5047\u8bbe\u5355\u5143\u53d8\u5f62\u68af\u5ea6\uff08deformation gradient\uff09\u4e3a \\boldsymbol{F} \\boldsymbol{F} \uff0c\u5219\u53d8\u5f62\u540e\uff0c\u9897\u7c92 p p \uff08\u521d\u59cb\u4f4d\u7f6e \\boldsymbol{X}^p \\boldsymbol{X}^p \uff09\u4e0e \u9897\u7c92 q q \uff08\u521d\u59cb\u4f4d\u7f6e (\\boldsymbol{X}^q (\\boldsymbol{X}^q \uff09\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf \\boldsymbol{d} \\boldsymbol{d} \u53ef\u8ba1\u7b97\u4e3a \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \u672c\u6784\u5f20\u91cf (Constitutive tangent moduli) \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \u53c2\u8003\u6587\u732e 1 2 3 4 5 DEM wiki \u250a Previous \u53c2\u8003\u6587\u732e R. I. Borja and J. R. Wren. Micromechanics of granular media Part I: Generation of overall constitutive equation for assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 127(1-4):13\u201336, November 1995. doi:10.1016/0045-7825(95)00846-2 . \u21a9 K. Bagi. Stress and strain in granular assemblies. Mechanics of Materials , 22(3):165\u2013177, March 1996. doi:10.1016/0167-6636(95)00044-5 . \u21a9 J. R. Wren and R. I. Borja. Micromechanics of granular media Part II: Overall tangential moduli and localization model for periodic assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 141(3):221\u2013246, February 1997. doi:10.1016/S0045-7825(96)01110-3 . \u21a9 N. P. Kruyt and L. Rothenburg. Statistical theories for the elastic moduli of two-dimensional assemblies of granular materials. International Journal of Engineering Science , 36(10):1127\u20131142, August 1998. doi:10.1016/S0020-7225(98)00003-2 . \u21a9 S. Luding. Micro\u2013macro transition for anisotropic, frictional granular packings. International Journal of Solids and Structures , 41(21):5821\u20135836, October 2004. doi:10.1016/j.ijsolstr.2004.05.048 . \u21a9","title":"Discrete to continuum"},{"location":"documentation/discrete_to_continuum/#_1","text":"DEM wiki \u250a Previous [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.]","title":""},{"location":"documentation/discrete_to_continuum/#stress","text":"\u57fa\u4e8e\u8fde\u7eed\u6027\u4ecb\u8d28\u7406\u8bba\uff0c\u6750\u6599\u7684\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u8868\u793a\u4e3a\uff08\u5ffd\u7565\u4f53\u529b\u53ca\u52a0\u901f\u5ea6\u9879\uff09 \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \u91c7\u7528\u7231\u56e0\u65af\u5766\u6c42\u548c\u7ea6\u5b9a\uff0c\u4e0a\u5f0f\u53ef\u5199\u4f5c \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \u5229\u7528\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u5f97\u7b49\u5f0f \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \u9488\u5bf9\u67d0\u4e2a\u9897\u7c92 p p \uff0c\u5176\u5185\u90e8\u5e94\u529b\u7684\u79ef\u5206\u53ef\u8ba1\u7b97\u4e3a \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \u5176\u4e2d\uff0c c c \u8868\u793a\u8be5\u9897\u7c92\u7684\u6240\u6709\u63a5\u89e6\u3001 f_j f_j \u8868\u793a\u63a5\u89e6\u529b\u3001 x_k x_k \u8868\u793a\u63a5\u89e6\u4f4d\u7f6e\u3002\u8fdb\u800c\uff0c\u5229\u7528\u9897\u7c92\u5728\u63a5\u89e6\u529b\u4f5c\u7528\u4e0b\u7684\u9759\u529b\u5e73\u8861\u516c\u5f0f \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \u53ef\u5f97 \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \u5176\u4e2d\uff0c x_k^p x_k^p \u4e3a\u9897\u7c92\u8d28\u5fc3\u3001 b_k b_k \u4e3a\u7531\u63a5\u89e6\u70b9\u6307\u5411\u9897\u7c92\u8d28\u5fc3\u7684\u5411\u91cf\uff08branch vector\uff09\u3002 \u9488\u5bf9\u4ee3\u8868\u5355\u5143\u4f53\uff0c\u5176\u57df\u5185\u7684\u5e73\u5747\u5e94\u529b\u53ef\u7531\u5176\u5185\u90e8\u6240\u6709\u9897\u7c92\u5185\u90e8\u7684\u5e94\u529b\u79ef\u5206\uff0c\u518d\u9664\u4e8e\u4ee3\u8868\u5355\u5143\u4f53\u4f53\u79ef\u5f97\u5230\uff0c\u8868\u8fbe\u4e3a \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \u5176\u4e2d\uff0c c c \u4e3a\u4ee3\u8868\u5355\u5143\u4f53\u5185\u7684\u6240\u6709\u63a5\u89e6\u3001 d_k d_k \u8868\u793a\u9897\u7c92\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf\u3002","title":"\u5e94\u529b (Stress)"},{"location":"documentation/discrete_to_continuum/#strain","text":"\u5047\u8bbe\u5355\u5143\u53d8\u5f62\u68af\u5ea6\uff08deformation gradient\uff09\u4e3a \\boldsymbol{F} \\boldsymbol{F} \uff0c\u5219\u53d8\u5f62\u540e\uff0c\u9897\u7c92 p p \uff08\u521d\u59cb\u4f4d\u7f6e \\boldsymbol{X}^p \\boldsymbol{X}^p \uff09\u4e0e \u9897\u7c92 q q \uff08\u521d\u59cb\u4f4d\u7f6e (\\boldsymbol{X}^q (\\boldsymbol{X}^q \uff09\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf \\boldsymbol{d} \\boldsymbol{d} \u53ef\u8ba1\u7b97\u4e3a \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align}","title":"\u5e94\u53d8 (Strain)"},{"location":"documentation/discrete_to_continuum/#constitutive-tangent-moduli","text":"\\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \u53c2\u8003\u6587\u732e 1 2 3 4 5 DEM wiki \u250a Previous","title":"\u672c\u6784\u5f20\u91cf (Constitutive tangent moduli)"},{"location":"documentation/discrete_to_continuum/#_2","text":"R. I. Borja and J. R. Wren. Micromechanics of granular media Part I: Generation of overall constitutive equation for assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 127(1-4):13\u201336, November 1995. doi:10.1016/0045-7825(95)00846-2 . \u21a9 K. Bagi. Stress and strain in granular assemblies. Mechanics of Materials , 22(3):165\u2013177, March 1996. doi:10.1016/0167-6636(95)00044-5 . \u21a9 J. R. Wren and R. I. Borja. Micromechanics of granular media Part II: Overall tangential moduli and localization model for periodic assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 141(3):221\u2013246, February 1997. doi:10.1016/S0045-7825(96)01110-3 . \u21a9 N. P. Kruyt and L. Rothenburg. Statistical theories for the elastic moduli of two-dimensional assemblies of granular materials. International Journal of Engineering Science , 36(10):1127\u20131142, August 1998. doi:10.1016/S0020-7225(98)00003-2 . \u21a9 S. Luding. Micro\u2013macro transition for anisotropic, frictional granular packings. International Journal of Solids and Structures , 41(21):5821\u20135836, October 2004. doi:10.1016/j.ijsolstr.2004.05.048 . \u21a9","title":"\u53c2\u8003\u6587\u732e"},{"location":"documentation/docker_hpc/","text":"User manual Docker Create a ubuntu image, and then create a apaam container User manual","title":"Docker hpc"},{"location":"documentation/docker_hpc/#_1","text":"User manual","title":""},{"location":"documentation/docker_hpc/#docker","text":"Create a ubuntu image, and then create a apaam container User manual","title":"Docker"},{"location":"documentation/installation/","text":"User manual \u250a Next Installation Prerequisites The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev Compile and build make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again. Test the installation ./scripts/run_tests.sh Related to installation Installation on Apple M1 (As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures. Dependencies git , gcc , cmake : for code developing, configuring and compiling open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb pybind : for python interface Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu. User manual \u250a Next","title":"Installation"},{"location":"documentation/installation/#_1","text":"User manual \u250a Next","title":""},{"location":"documentation/installation/#installation","text":"","title":"Installation"},{"location":"documentation/installation/#prerequisites","text":"The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev","title":"Prerequisites"},{"location":"documentation/installation/#compile-and-build","text":"make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again.","title":"Compile and build"},{"location":"documentation/installation/#test-the-installation","text":"./scripts/run_tests.sh","title":"Test the installation"},{"location":"documentation/installation/#related-to-installation","text":"","title":"Related to installation"},{"location":"documentation/installation/#installation-on-apple-m1","text":"(As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures.","title":"Installation on Apple M1"},{"location":"documentation/installation/#dependencies","text":"git , gcc , cmake : for code developing, configuring and compiling open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb pybind : for python interface Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu. User manual \u250a Next","title":"Dependencies"},{"location":"documentation/paraview_rendering/","text":"User manual \u250a Previous \u250a Next Rendering in paraview Results can be dumped as VTK files, which can be visualized in paraview . Spherical particles Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range . General particles and walls Reconstruc the mesh of particles and walls ; Import to praview; Contact force chain Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes. Ray tracing Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section. Create animation In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c. Client/Server Establish tunneling using: ssh -L 11111:localhost:11111 -p [port] [user]@[remote-ip] Start pvserver on remote pvserver Open paraview at local, add and connect to server with type Client/Server , host localhost and port 11111 User manual \u250a Previous \u250a Next","title":"Paraview rendering"},{"location":"documentation/paraview_rendering/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/paraview_rendering/#rendering-in-paraview","text":"Results can be dumped as VTK files, which can be visualized in paraview .","title":"Rendering in paraview"},{"location":"documentation/paraview_rendering/#spherical-particles","text":"Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range .","title":"Spherical particles"},{"location":"documentation/paraview_rendering/#general-particles-and-walls","text":"Reconstruc the mesh of particles and walls ; Import to praview;","title":"General particles and walls"},{"location":"documentation/paraview_rendering/#contact-force-chain","text":"Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes.","title":"Contact force chain"},{"location":"documentation/paraview_rendering/#ray-tracing","text":"Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section.","title":"Ray tracing"},{"location":"documentation/paraview_rendering/#create-animation","text":"In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c.","title":"Create animation"},{"location":"documentation/paraview_rendering/#clientserver","text":"Establish tunneling using: ssh -L 11111:localhost:11111 -p [port] [user]@[remote-ip] Start pvserver on remote pvserver Open paraview at local, add and connect to server with type Client/Server , host localhost and port 11111 User manual \u250a Previous \u250a Next","title":"Client/Server"},{"location":"documentation/particle_models/","text":"DEM wiki \u250a Previous \u250a Next [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.] \u805a\u5408\u8d85\u692d\u7403\uff08Poly-super-ellipsoid\uff09 \u8868\u8fbe\u5f0f\uff08Formulation\uff09 \u8d85\u692d\u7403\u7684\u8868\u9762\u53ef\u8868\u793a\u4e3a 1 \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u692d\u7403\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u662f\u8868\u5f81\u8d85\u692d\u7403\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e24\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u692d\u7403\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u692d\u7403\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b r_{y} r_{y} \u548c r_{z} r_{z} \u4ea6\u7136\u3002 \u652f\u6491\u6620\u5c04\uff08Support mapping\uff09 \u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a\uff08\u6ce8\uff0c\u4ee5\u7b2c\u4e00\u8c61\u9650\u4e3a\u4f8b\u3001\u6b63\u8d1f\u53f7\u5df2\u7701\u7565\uff09 \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \uff09 \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7403\u5750\u6807\u53c2\u6570 \\theta \\theta \u548c \\varphi \\varphi \u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\uff08Signed distance field\uff09 \u7ed9\u5b9a\u67e5\u8be2\u8282\u70b9 P P \uff0c\u8be5\u70b9\u5728\u805a\u5408\u8d85\u692d\u7403\u8868\u9762\u7684\u6295\u5f71\u5b9a\u4e49\u4e3a \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \u5176\u4e2d\uff0c x x \u3001 y y \u548c z z \u8868\u793a\u70b9\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5750\u6807\uff1b\u4e0b\u6807 P P and Q Q \u8868\u793a\u70b9 P P \u548c Q Q \uff1b\u53c2\u6570 c c \u4e3a\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97\u70b9 Q Q \u5728\u805a\u5408\u8d85\u692d\u7403\u4e0a\uff0c\u5373\u6ee1\u8db3\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid}\u3002 \u5c06\u70b9 Q Q \u5e26\u5165\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid} \u53ef\u6c42\u5f97\u53c2\u6570 c c \uff0c\u4e3a \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\u53ef\u5b9a\u4e49\u4e3a\u70b9 P P \u548c Q Q \u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u4e3a \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \u5176\u4e2d\uff0c ||\\vec{x}_P|| ||\\vec{x}_P|| \u8868\u793a\u5411\u91cf \\vec{x}_P \\vec{x}_P \u7684\u6b27\u62c9\u957f\u5ea6\uff0c\u5373\u4e8c\u9636\u8303\u6570\u3002 \u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff08Poly-super-quadrics) \u8868\u8fbe\u5f0f\uff08Formulation\uff09 \u8d85\u4e8c\u6b21\u66f2\u9762\u53ef\u8868\u793a\u4e3a \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u4e8c\u6b21\u66f2\u9762\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u662f\u8868\u5f81\u8d85\u4e8c\u6b21\u66f2\u9762\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e09\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u4e8c\u6b21\u66f2\u9762\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b\u5f62\u72b6\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^-} \\epsilon_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^+} \\epsilon_{x^+} \uff1b r_{y} r_{y} \u3001 r_{z} r_{z} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u4ea6\u7136\u3002 \u652f\u6491\u6620\u5c04\uff08Support mapping\uff09 \u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \uff09 \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7b1b\u5361\u5c14\u5750\u6807\u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \u5c06\u4e0a\u5f0f\u5e26\u5165\u516c\u5f0f\\eqref{eq:poly_super_quadrics}\u53ef\u6c42\u5f97\u7cfb\u6570 k k \uff0c\u8fdb\u800c\u5f97\u5230\u8be5\u70b9\u7684\u5750\u6807 x x \u3001 y y \u548c z z \u3002 DEM wiki \u250a Previous \u250a Next \u53c2\u8003\u6587\u732e S. Zhao and J. Zhao. A poly-superellipsoid-based approach on particle morphology for DEM modeling of granular media. International Journal for Numerical and Analytical Methods in Geomechanics , 43(13):2147\u20132169, 2019. \u21a9","title":"Particle models"},{"location":"documentation/particle_models/#_1","text":"DEM wiki \u250a Previous \u250a Next [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.]","title":""},{"location":"documentation/particle_models/#poly-super-ellipsoid","text":"","title":"\u805a\u5408\u8d85\u692d\u7403\uff08Poly-super-ellipsoid\uff09"},{"location":"documentation/particle_models/#formulation","text":"\u8d85\u692d\u7403\u7684\u8868\u9762\u53ef\u8868\u793a\u4e3a 1 \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u692d\u7403\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u662f\u8868\u5f81\u8d85\u692d\u7403\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e24\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u692d\u7403\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u692d\u7403\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b r_{y} r_{y} \u548c r_{z} r_{z} \u4ea6\u7136\u3002","title":"\u8868\u8fbe\u5f0f\uff08Formulation\uff09"},{"location":"documentation/particle_models/#support-mapping","text":"\u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a\uff08\u6ce8\uff0c\u4ee5\u7b2c\u4e00\u8c61\u9650\u4e3a\u4f8b\u3001\u6b63\u8d1f\u53f7\u5df2\u7701\u7565\uff09 \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \uff09 \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7403\u5750\u6807\u53c2\u6570 \\theta \\theta \u548c \\varphi \\varphi \u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align}","title":"\u652f\u6491\u6620\u5c04\uff08Support mapping\uff09"},{"location":"documentation/particle_models/#signed-distance-field","text":"\u7ed9\u5b9a\u67e5\u8be2\u8282\u70b9 P P \uff0c\u8be5\u70b9\u5728\u805a\u5408\u8d85\u692d\u7403\u8868\u9762\u7684\u6295\u5f71\u5b9a\u4e49\u4e3a \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \u5176\u4e2d\uff0c x x \u3001 y y \u548c z z \u8868\u793a\u70b9\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5750\u6807\uff1b\u4e0b\u6807 P P and Q Q \u8868\u793a\u70b9 P P \u548c Q Q \uff1b\u53c2\u6570 c c \u4e3a\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97\u70b9 Q Q \u5728\u805a\u5408\u8d85\u692d\u7403\u4e0a\uff0c\u5373\u6ee1\u8db3\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid}\u3002 \u5c06\u70b9 Q Q \u5e26\u5165\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid} \u53ef\u6c42\u5f97\u53c2\u6570 c c \uff0c\u4e3a \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\u53ef\u5b9a\u4e49\u4e3a\u70b9 P P \u548c Q Q \u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u4e3a \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \u5176\u4e2d\uff0c ||\\vec{x}_P|| ||\\vec{x}_P|| \u8868\u793a\u5411\u91cf \\vec{x}_P \\vec{x}_P \u7684\u6b27\u62c9\u957f\u5ea6\uff0c\u5373\u4e8c\u9636\u8303\u6570\u3002","title":"\u6709\u5411\u8ddd\u79bb\u573a\uff08Signed distance field\uff09"},{"location":"documentation/particle_models/#poly-super-quadrics","text":"","title":"\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff08Poly-super-quadrics)"},{"location":"documentation/particle_models/#formulation_1","text":"\u8d85\u4e8c\u6b21\u66f2\u9762\u53ef\u8868\u793a\u4e3a \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u4e8c\u6b21\u66f2\u9762\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u662f\u8868\u5f81\u8d85\u4e8c\u6b21\u66f2\u9762\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e09\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u4e8c\u6b21\u66f2\u9762\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b\u5f62\u72b6\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^-} \\epsilon_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^+} \\epsilon_{x^+} \uff1b r_{y} r_{y} \u3001 r_{z} r_{z} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u4ea6\u7136\u3002","title":"\u8868\u8fbe\u5f0f\uff08Formulation\uff09"},{"location":"documentation/particle_models/#support-mapping_1","text":"\u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \uff09 \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7b1b\u5361\u5c14\u5750\u6807\u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \u5c06\u4e0a\u5f0f\u5e26\u5165\u516c\u5f0f\\eqref{eq:poly_super_quadrics}\u53ef\u6c42\u5f97\u7cfb\u6570 k k \uff0c\u8fdb\u800c\u5f97\u5230\u8be5\u70b9\u7684\u5750\u6807 x x \u3001 y y \u548c z z \u3002 DEM wiki \u250a Previous \u250a Next","title":"\u652f\u6491\u6620\u5c04\uff08Support mapping\uff09"},{"location":"documentation/particle_models/#_2","text":"S. Zhao and J. Zhao. A poly-superellipsoid-based approach on particle morphology for DEM modeling of granular media. International Journal for Numerical and Analytical Methods in Geomechanics , 43(13):2147\u20132169, 2019. \u21a9","title":"\u53c2\u8003\u6587\u732e"},{"location":"documentation/ref_dem/","text":"User manual \u250a Next ContactModel This class represents a contact model. Constructor ContactModel(label='') Creates a new instance of the ContactModel class. label (string, optional): A string label for the contact model. Default is an empty string. Attributes label A string label for the contact model. Methods SetProperty(json_data) Set the properties of the contact model from a JSON object. json_data (JSON object): A JSON object containing the properties to set. SetProperty(prop_name, prop_value) Set a specific property of the contact model. prop_name (string): The name of the property to set. prop_value (float): The value to set for the property. LinearSpring This class represents a linear spring. Constructor LinearSpring() Creates a new instance of the LinearSpring class. LinearSpring(stiffness, damping, rest_length, contact_radius) Creates a new instance of the LinearSpring class with specific parameters. stiffness (float): The spring stiffness. damping (float): The spring damping. rest_length (float): The rest length of the spring. contact_radius (float): The contact radius of the spring. ParallelBond This class represents a parallel bond contact model. Constructor ParallelBond() Creates a new instance of the ParallelBond class. ParallelBond(kn, kt, gamma, t0) Creates a new instance of the ParallelBond class with specified parameters. kn (float): Normal contact stiffness. kt (float): Tangential contact stiffness. gamma (float): Viscoelastic parameter. t0 (float): Yield strength. Inheritance ParallelBond inherits from ContactModel ContactSolverSettings Class This class represents settings for the contact solver. Attributes solver_type (SolverType) The type of contact solver to use. Default is SolverType. gjk_use_erosion (bool) Whether to use erosion for the GJK contact solver. gjk_erosion_ratio_initial (float) The initial erosion ratio for the GJK contact solver. gjk_erosion_ratio_increment (float) The increment of erosion ratio for the GJK contact solver. sdf_potential_type (int) The type of potential function to use for the SDF contact solver. SolverType Enumeration This enumeration represents the type of contact solver. SolverType.gjk : The GJK contact solver. SolverType.sdf : The SDF contact solver. SolverType.automatic : The automatic contact solver. ContactSolverFactory This class is responsible for creating instances of contact solvers based on settings. Attributes settings (ContactSolverSettings): The settings for the contact solver. Methods init (): Constructs a new instance of the ContactSolverFactory class with default settings. init (factory: ContactSolverFactory): Constructs a new instance of the ContactSolverFactory class with settings copied from factory. copy (): Copies the settings of the contact solver factory to a new instance of the ContactSolverFactory class. DEMSolver This class represents a discrete element method (DEM) solver. Constructor DEMSolver() Creates a new instance of the DEMSolver class. Attributes timestep The timestep used for the simulation. contact_solver_factory The contact solver factory used to create contact solvers for the simulation. Enums CyclePoint An enumeration representing the different cycle points in the simulation. pre : The pre-collision cycle point. mid_0 : The first mid-collision cycle point. mid_1 : The second mid-collision cycle point. mid_2 : The third mid-collision cycle point. mid_3 : The fourth mid-collision cycle point. mid_4 : The fifth mid-collision cycle point. post : The post-collision cycle point. User manual \u250a Next","title":"Ref dem"},{"location":"documentation/ref_dem/#_1","text":"User manual \u250a Next","title":""},{"location":"documentation/ref_dem/#contactmodel","text":"This class represents a contact model.","title":"ContactModel"},{"location":"documentation/ref_dem/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_dem/#contactmodellabel","text":"Creates a new instance of the ContactModel class. label (string, optional): A string label for the contact model. Default is an empty string.","title":"ContactModel(label='')"},{"location":"documentation/ref_dem/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_dem/#label","text":"A string label for the contact model.","title":"label"},{"location":"documentation/ref_dem/#methods","text":"","title":"Methods"},{"location":"documentation/ref_dem/#setpropertyjson_data","text":"Set the properties of the contact model from a JSON object. json_data (JSON object): A JSON object containing the properties to set.","title":"SetProperty(json_data)"},{"location":"documentation/ref_dem/#setpropertyprop_name-prop_value","text":"Set a specific property of the contact model. prop_name (string): The name of the property to set. prop_value (float): The value to set for the property.","title":"SetProperty(prop_name, prop_value)"},{"location":"documentation/ref_dem/#linearspring","text":"This class represents a linear spring.","title":"LinearSpring"},{"location":"documentation/ref_dem/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_dem/#linearspring_1","text":"Creates a new instance of the LinearSpring class.","title":"LinearSpring()"},{"location":"documentation/ref_dem/#linearspringstiffness-damping-rest_length-contact_radius","text":"Creates a new instance of the LinearSpring class with specific parameters. stiffness (float): The spring stiffness. damping (float): The spring damping. rest_length (float): The rest length of the spring. contact_radius (float): The contact radius of the spring.","title":"LinearSpring(stiffness, damping, rest_length, contact_radius)"},{"location":"documentation/ref_dem/#parallelbond","text":"This class represents a parallel bond contact model.","title":"ParallelBond"},{"location":"documentation/ref_dem/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_dem/#parallelbond_1","text":"Creates a new instance of the ParallelBond class.","title":"ParallelBond()"},{"location":"documentation/ref_dem/#parallelbondkn-kt-gamma-t0","text":"Creates a new instance of the ParallelBond class with specified parameters. kn (float): Normal contact stiffness. kt (float): Tangential contact stiffness. gamma (float): Viscoelastic parameter. t0 (float): Yield strength.","title":"ParallelBond(kn, kt, gamma, t0)"},{"location":"documentation/ref_dem/#inheritance","text":"ParallelBond inherits from ContactModel","title":"Inheritance"},{"location":"documentation/ref_dem/#contactsolversettings-class","text":"This class represents settings for the contact solver.","title":"ContactSolverSettings Class"},{"location":"documentation/ref_dem/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_dem/#solver_type-solvertype","text":"The type of contact solver to use. Default is SolverType.","title":"solver_type (SolverType)"},{"location":"documentation/ref_dem/#gjk_use_erosion-bool","text":"Whether to use erosion for the GJK contact solver.","title":"gjk_use_erosion (bool)"},{"location":"documentation/ref_dem/#gjk_erosion_ratio_initial-float","text":"The initial erosion ratio for the GJK contact solver.","title":"gjk_erosion_ratio_initial (float)"},{"location":"documentation/ref_dem/#gjk_erosion_ratio_increment-float","text":"The increment of erosion ratio for the GJK contact solver.","title":"gjk_erosion_ratio_increment (float)"},{"location":"documentation/ref_dem/#sdf_potential_type-int","text":"The type of potential function to use for the SDF contact solver.","title":"sdf_potential_type (int)"},{"location":"documentation/ref_dem/#solvertype-enumeration","text":"This enumeration represents the type of contact solver.","title":"SolverType Enumeration"},{"location":"documentation/ref_dem/#solvertypegjk-the-gjk-contact-solver","text":"","title":"SolverType.gjk: The GJK contact solver."},{"location":"documentation/ref_dem/#solvertypesdf-the-sdf-contact-solver","text":"","title":"SolverType.sdf: The SDF contact solver."},{"location":"documentation/ref_dem/#solvertypeautomatic-the-automatic-contact-solver","text":"","title":"SolverType.automatic: The automatic contact solver."},{"location":"documentation/ref_dem/#contactsolverfactory","text":"This class is responsible for creating instances of contact solvers based on settings.","title":"ContactSolverFactory"},{"location":"documentation/ref_dem/#attributes_2","text":"settings (ContactSolverSettings): The settings for the contact solver.","title":"Attributes"},{"location":"documentation/ref_dem/#methods_1","text":"init (): Constructs a new instance of the ContactSolverFactory class with default settings. init (factory: ContactSolverFactory): Constructs a new instance of the ContactSolverFactory class with settings copied from factory. copy (): Copies the settings of the contact solver factory to a new instance of the ContactSolverFactory class.","title":"Methods"},{"location":"documentation/ref_dem/#demsolver","text":"This class represents a discrete element method (DEM) solver.","title":"DEMSolver"},{"location":"documentation/ref_dem/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_dem/#demsolver_1","text":"Creates a new instance of the DEMSolver class.","title":"DEMSolver()"},{"location":"documentation/ref_dem/#attributes_3","text":"","title":"Attributes"},{"location":"documentation/ref_dem/#timestep","text":"The timestep used for the simulation.","title":"timestep"},{"location":"documentation/ref_dem/#contact_solver_factory","text":"The contact solver factory used to create contact solvers for the simulation.","title":"contact_solver_factory"},{"location":"documentation/ref_dem/#enums","text":"","title":"Enums"},{"location":"documentation/ref_dem/#cyclepoint","text":"An enumeration representing the different cycle points in the simulation. pre : The pre-collision cycle point. mid_0 : The first mid-collision cycle point. mid_1 : The second mid-collision cycle point. mid_2 : The third mid-collision cycle point. mid_3 : The fourth mid-collision cycle point. mid_4 : The fifth mid-collision cycle point. post : The post-collision cycle point. User manual \u250a Next","title":"CyclePoint"},{"location":"documentation/ref_domain/","text":"User manual \u250a Previous \u250a Next CellManager This class represents a cell manager. Constructor CellManager() Creates a new instance of the CellManager class. Methods SetSpacing(spacing) Set the spacing of the cell manager. spacing (float): The value of the spacing to set. Domain This class represents a computational domain. Constructor Domain() Creates a new instance of the Domain class. Attributes cell_manager An instance of the CellManager class. self_rank The rank of the current process. total_rank The total number of processes. bound_min The minimum bound of the domain. bound_max The maximum bound of the domain. Methods SetBound(bound_min, bound_max) Set the bounds of the domain. bound_min (Vec3): The minimum bound of the domain. bound_max (Vec3): The maximum bound of the domain. SetCellSpacing(spacing) Set the spacing between cells. spacing (Vec3): The spacing between cells. IsJudgeDomain(particle1, particle2) Check if two particles belong to the same domain. particle1 (Particle): The first particle. particle2 (Particle): The second particle. IsJudgeDomain(particle, wall) Check if a particle and a wall belong to the same domain. particle (Particle): The particle. wall (Wall): The wall. IsBelongToDomain(particle) Check if a particle belongs to the domain. particle (Particle): The particle. IsBelongToDomain(particle_data) Check if a particle data belongs to the domain. particle_data (ParticleData): The particle data. DomainManager This class manages the domains in a distributed computing environment. Constructor DomainManager() Creates a new instance of the DomainManager class. Methods SetBound(bound_min, bound_max) Sets the bounding box of the domains. bound_min (tuple of floats): The minimum coordinates of the bounding box. bound_max (tuple of floats): The maximum coordinates of the bounding box. SetDecomposition(num_subdomains) Sets the number of subdomains for decomposition. num_subdomains (int): The number of subdomains to decompose the domain into. SetCellSpacing(spacing) Sets the cell spacing for the subdomains. spacing (float): The cell spacing for the subdomains. GetGhostSubDomains() Returns a list of ghost subdomains. GetSelfGhostSubDomain() Returns the ghost subdomain for the current process. GetSelfSubDomain() Returns the subdomain for the current process. User manual \u250a Previous \u250a Next","title":"Ref domain"},{"location":"documentation/ref_domain/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_domain/#cellmanager","text":"This class represents a cell manager.","title":"CellManager"},{"location":"documentation/ref_domain/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_domain/#cellmanager_1","text":"Creates a new instance of the CellManager class.","title":"CellManager()"},{"location":"documentation/ref_domain/#methods","text":"","title":"Methods"},{"location":"documentation/ref_domain/#setspacingspacing","text":"Set the spacing of the cell manager. spacing (float): The value of the spacing to set.","title":"SetSpacing(spacing)"},{"location":"documentation/ref_domain/#domain","text":"This class represents a computational domain.","title":"Domain"},{"location":"documentation/ref_domain/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_domain/#domain_1","text":"Creates a new instance of the Domain class.","title":"Domain()"},{"location":"documentation/ref_domain/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_domain/#cell_manager","text":"An instance of the CellManager class.","title":"cell_manager"},{"location":"documentation/ref_domain/#self_rank","text":"The rank of the current process.","title":"self_rank"},{"location":"documentation/ref_domain/#total_rank","text":"The total number of processes.","title":"total_rank"},{"location":"documentation/ref_domain/#bound_min","text":"The minimum bound of the domain.","title":"bound_min"},{"location":"documentation/ref_domain/#bound_max","text":"The maximum bound of the domain.","title":"bound_max"},{"location":"documentation/ref_domain/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_domain/#setboundbound_min-bound_max","text":"Set the bounds of the domain. bound_min (Vec3): The minimum bound of the domain. bound_max (Vec3): The maximum bound of the domain.","title":"SetBound(bound_min, bound_max)"},{"location":"documentation/ref_domain/#setcellspacingspacing","text":"Set the spacing between cells. spacing (Vec3): The spacing between cells.","title":"SetCellSpacing(spacing)"},{"location":"documentation/ref_domain/#isjudgedomainparticle1-particle2","text":"Check if two particles belong to the same domain. particle1 (Particle): The first particle. particle2 (Particle): The second particle.","title":"IsJudgeDomain(particle1, particle2)"},{"location":"documentation/ref_domain/#isjudgedomainparticle-wall","text":"Check if a particle and a wall belong to the same domain. particle (Particle): The particle. wall (Wall): The wall.","title":"IsJudgeDomain(particle, wall)"},{"location":"documentation/ref_domain/#isbelongtodomainparticle","text":"Check if a particle belongs to the domain. particle (Particle): The particle.","title":"IsBelongToDomain(particle)"},{"location":"documentation/ref_domain/#isbelongtodomainparticle_data","text":"Check if a particle data belongs to the domain. particle_data (ParticleData): The particle data.","title":"IsBelongToDomain(particle_data)"},{"location":"documentation/ref_domain/#domainmanager","text":"This class manages the domains in a distributed computing environment.","title":"DomainManager"},{"location":"documentation/ref_domain/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_domain/#domainmanager_1","text":"Creates a new instance of the DomainManager class.","title":"DomainManager()"},{"location":"documentation/ref_domain/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_domain/#setboundbound_min-bound_max_1","text":"Sets the bounding box of the domains. bound_min (tuple of floats): The minimum coordinates of the bounding box. bound_max (tuple of floats): The maximum coordinates of the bounding box.","title":"SetBound(bound_min, bound_max)"},{"location":"documentation/ref_domain/#setdecompositionnum_subdomains","text":"Sets the number of subdomains for decomposition. num_subdomains (int): The number of subdomains to decompose the domain into.","title":"SetDecomposition(num_subdomains)"},{"location":"documentation/ref_domain/#setcellspacingspacing_1","text":"Sets the cell spacing for the subdomains. spacing (float): The cell spacing for the subdomains.","title":"SetCellSpacing(spacing)"},{"location":"documentation/ref_domain/#getghostsubdomains","text":"Returns a list of ghost subdomains.","title":"GetGhostSubDomains()"},{"location":"documentation/ref_domain/#getselfghostsubdomain","text":"Returns the ghost subdomain for the current process.","title":"GetSelfGhostSubDomain()"},{"location":"documentation/ref_domain/#getselfsubdomain","text":"Returns the subdomain for the current process. User manual \u250a Previous \u250a Next","title":"GetSelfSubDomain()"},{"location":"documentation/ref_fem/","text":"User manual \u250a Previous \u250a Next TetMesh This class represents a tetrahedral mesh. Constructor TetMesh() Creates a new instance of the TetMesh class. TetMesh(nodes, elements, scale) Creates a new instance of the TetMesh class from the given nodes and elements, with the specified scale. nodes (list of Vec3d): The list of nodes. elements (list of Vec3i): The list of elements. scale (float): The scaling factor. Attribution nodes The list of nodes. elements The list of elements. bound_facets The list of boundary facets. bound_edges The list of boundary edges. bound_nodes The list of boundary nodes. surface_nodes The list of surface nodes. surface_facets The list of surface facets. surface_node_linked_boundaries The list of surface node linked boundaries. Methods GetSurfaceSTL() Returns the surface mesh in STL format. SaveAsVTK(filename) Saves the mesh in VTK format to the specified file. filename (str): The name of the file to save to. Init() Initializes the mesh. Membrane This class represents a membrane in a simulation. Constructor __init__(radius, height) Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane. __init__(radius, height, mesh_size) Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane. mesh_size (float): The size of the mesh. __init__(radius, height, mesh_size, neo_k, neo_mu, density) Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane. mesh_size (float): The size of the mesh. neo_k (float): The Neo-Hookean constant of the membrane. neo_mu (float): The Neo-Hookean coefficient of the membrane. density (float): The density of the membrane. Attributes radius (float): The radius of the membrane. height (float): The height of the membrane. mesh_size (float): The size of the mesh. center (tuple of floats): The center coordinates of the membrane. neo_k (float): The Neo-Hookean constant of the membrane. neo_mu (float): The Neo-Hookean coefficient of the membrane. density (float): The density of the membrane. thickness (float): The thickness of the membrane. damp_coef (float): The damping coefficient of the membrane. timestep (float): The timestep of the membrane. nodes (list of tuples of floats): The coordinates of the nodes in the membrane. elements (list of tuples of ints): The connectivity of the elements in the membrane. elemental_stress (list of tuples of floats): The elemental stress of the membrane. nodal_vols (list of floats): The nodal volumes of the membrane. nodal_vels (list of tuples of floats): The nodal velocities of the membrane. bc_facet_pressure (list of floats): The boundary condition pressure of the membrane. bc_facet_forces (list of tuples of floats): The boundary condition forces of the membrane. bc_nodal_vels (list of tuples of floats): The boundary condition nodal velocities of the membrane. Methods Remesh() Remeshes the membrane. SetBCNodalVelocity(nodal_vels) Sets the boundary condition nodal velocities of the membrane. nodal_vels (list of tuples of floats): The boundary condition nodal velocities of the membrane. Init() Initializes the membrane. Solve() Solves the membrane. SaveAsVTK(filename: str) Saves the membrane as a VTK file. filename (str): The filename of the VTK file. User manual \u250a Previous \u250a Next","title":"Ref fem"},{"location":"documentation/ref_fem/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_fem/#tetmesh","text":"This class represents a tetrahedral mesh.","title":"TetMesh"},{"location":"documentation/ref_fem/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_fem/#tetmesh_1","text":"Creates a new instance of the TetMesh class.","title":"TetMesh()"},{"location":"documentation/ref_fem/#tetmeshnodes-elements-scale","text":"Creates a new instance of the TetMesh class from the given nodes and elements, with the specified scale. nodes (list of Vec3d): The list of nodes. elements (list of Vec3i): The list of elements. scale (float): The scaling factor.","title":"TetMesh(nodes, elements, scale)"},{"location":"documentation/ref_fem/#attribution","text":"","title":"Attribution"},{"location":"documentation/ref_fem/#nodes","text":"The list of nodes.","title":"nodes"},{"location":"documentation/ref_fem/#elements","text":"The list of elements.","title":"elements"},{"location":"documentation/ref_fem/#bound_facets","text":"The list of boundary facets.","title":"bound_facets"},{"location":"documentation/ref_fem/#bound_edges","text":"The list of boundary edges.","title":"bound_edges"},{"location":"documentation/ref_fem/#bound_nodes","text":"The list of boundary nodes.","title":"bound_nodes"},{"location":"documentation/ref_fem/#surface_nodes","text":"The list of surface nodes.","title":"surface_nodes"},{"location":"documentation/ref_fem/#surface_facets","text":"The list of surface facets.","title":"surface_facets"},{"location":"documentation/ref_fem/#surface_node_linked_boundaries","text":"The list of surface node linked boundaries.","title":"surface_node_linked_boundaries"},{"location":"documentation/ref_fem/#methods","text":"","title":"Methods"},{"location":"documentation/ref_fem/#getsurfacestl","text":"Returns the surface mesh in STL format.","title":"GetSurfaceSTL()"},{"location":"documentation/ref_fem/#saveasvtkfilename","text":"Saves the mesh in VTK format to the specified file. filename (str): The name of the file to save to.","title":"SaveAsVTK(filename)"},{"location":"documentation/ref_fem/#init","text":"Initializes the mesh.","title":"Init()"},{"location":"documentation/ref_fem/#membrane","text":"This class represents a membrane in a simulation.","title":"Membrane"},{"location":"documentation/ref_fem/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_fem/#__init__radius-height","text":"Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane.","title":"__init__(radius, height)"},{"location":"documentation/ref_fem/#__init__radius-height-mesh_size","text":"Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane. mesh_size (float): The size of the mesh.","title":"__init__(radius, height, mesh_size)"},{"location":"documentation/ref_fem/#__init__radius-height-mesh_size-neo_k-neo_mu-density","text":"Creates a new instance of the PyMembrane class. radius (float): The radius of the membrane. height (float): The height of the membrane. mesh_size (float): The size of the mesh. neo_k (float): The Neo-Hookean constant of the membrane. neo_mu (float): The Neo-Hookean coefficient of the membrane. density (float): The density of the membrane.","title":"__init__(radius, height, mesh_size, neo_k, neo_mu, density)"},{"location":"documentation/ref_fem/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_fem/#radius-float","text":"The radius of the membrane.","title":"radius (float):"},{"location":"documentation/ref_fem/#height-float","text":"The height of the membrane.","title":"height (float):"},{"location":"documentation/ref_fem/#mesh_size-float","text":"The size of the mesh.","title":"mesh_size (float):"},{"location":"documentation/ref_fem/#center-tuple-of-floats","text":"The center coordinates of the membrane. neo_k (float): The Neo-Hookean constant of the membrane. neo_mu (float): The Neo-Hookean coefficient of the membrane. density (float): The density of the membrane. thickness (float): The thickness of the membrane. damp_coef (float): The damping coefficient of the membrane. timestep (float): The timestep of the membrane. nodes (list of tuples of floats): The coordinates of the nodes in the membrane. elements (list of tuples of ints): The connectivity of the elements in the membrane. elemental_stress (list of tuples of floats): The elemental stress of the membrane. nodal_vols (list of floats): The nodal volumes of the membrane. nodal_vels (list of tuples of floats): The nodal velocities of the membrane. bc_facet_pressure (list of floats): The boundary condition pressure of the membrane. bc_facet_forces (list of tuples of floats): The boundary condition forces of the membrane. bc_nodal_vels (list of tuples of floats): The boundary condition nodal velocities of the membrane.","title":"center (tuple of floats):"},{"location":"documentation/ref_fem/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_fem/#remesh","text":"Remeshes the membrane.","title":"Remesh()"},{"location":"documentation/ref_fem/#setbcnodalvelocitynodal_vels","text":"Sets the boundary condition nodal velocities of the membrane. nodal_vels (list of tuples of floats): The boundary condition nodal velocities of the membrane.","title":"SetBCNodalVelocity(nodal_vels)"},{"location":"documentation/ref_fem/#init_1","text":"Initializes the membrane.","title":"Init()"},{"location":"documentation/ref_fem/#solve","text":"Solves the membrane.","title":"Solve()"},{"location":"documentation/ref_fem/#saveasvtkfilename-str","text":"Saves the membrane as a VTK file. filename (str): The filename of the VTK file. User manual \u250a Previous \u250a Next","title":"SaveAsVTK(filename: str)"},{"location":"documentation/ref_modifier/","text":"User manual \u250a Previous \u250a Next ModifierManager This class manages a collection of modifiers that can be enabled or disabled. Constructor ModifierManager() Creates a new instance of the ModifierManager class. Methods Insert(modifier) Inserts a modifier into the manager. modifier (Modifier): The modifier to insert. Enable(modifier) Enables a modifier. modifier (Modifier): The modifier to enable. Enable(name) Enables a modifier by name. name (string): The name of the modifier to enable. Disable(modifier) Disables a modifier. modifier (Modifier): The modifier to disable. Disable(name) Disables a modifier by name. name (string): The name of the modifier to disable. Modifier This class represents a modifier. Constructor Modifier() Creates a new instance of the Modifier class. Attributes label A string label for the modifier. cycle_point An integer representing the cycle point at which the modifier will be executed. sim A pointer to the simulation object associated with the modifier. scene A pointer to the scene object associated with the modifier. update_with_scene A boolean indicating whether the modifier should update with the scene. enable_logging A boolean indicating whether logging should be enabled for the modifier. Methods Clone() Creates a new instance of the modifier. Init() Initializes the modifier. Enable() Enables the modifier. Disable() Disables the modifier. Execute() Executes the modifier. Update() Updates the modifier. BreakageAnalysisPD This class represents a breakage analysis for particles in a DEM simulation. Constructor BreakageAnalysisPD() Creates a new instance of the BreakageAnalysisPD class. Attributes particle_id_list A list of particle IDs to include in the breakage analysis. use_particles_in_scene A boolean indicating whether to use all particles in the scene or only the particles in the particle_id_list. pd_dem_coupler An instance of the PdDemCoupler class used to couple the breakage analysis with the DEM simulation. Methods SetRootPath(root_path) Sets the root path for the breakage analysis output files. root_path (string): The path to the root directory for the output files. SetExecuteByTime(start_time, end_time, time_step) Sets the time range and time step for the breakage analysis execution. start_time (float): The start time for the breakage analysis. end_time (float): The end time for the breakage analysis. time_step (float): The time step for the breakage analysis. SetExecuteByCycles(start_cycle, end_cycle, cycle_step) Sets the cycle range and cycle step for the breakage analysis execution. start_cycle (int): The start cycle for the breakage analysis. end_cycle (int): The end cycle for the breakage analysis. cycle_step (int): The cycle step for the breakage analysis. SetParticlesFromScene() Sets the particles to include in the breakage analysis based on the particles in the current DEM simulation scene. SetParticles(particles) Sets the particles to include in the breakage analysis. particles (list of ints or initializer list of ints): The list of particle IDs to include in the breakage analysis. Cast() Returns a reference to the current instance of the BreakageAnalysisPD class as a Modifier object. DataDumper This class is responsible for dumping data from the simulation to file. Constructor DataDumper() Creates a new instance of the DataDumper class. Attributes dump_particle_info A boolean flag indicating whether particle information should be dumped. dump_wall_info A boolean flag indicating whether wall information should be dumped. dump_contact_info A boolean flag indicating whether contact information should be dumped. dump_shape_info A boolean flag indicating whether shape information should be dumped. dump_mesh A boolean flag indicating whether mesh information should be dumped. dump_reconstructed A boolean flag indicating whether reconstructed information should be dumped. time_stamp_adjustable A boolean flag indicating whether the time stamp is adjustable. Methods SetRootPath(root_path) Sets the root path where the data will be dumped. root_path (string): The root path where the data will be dumped. SetSaveByTime(save_by_time, time_interval) Sets whether the data should be saved based on a time interval. save_by_time (bool): A boolean flag indicating whether the data should be saved based on a time interval. time_interval (float): The time interval for saving the data. SetSaveByCycles(save_by_cycles, cycle_interval) Sets whether the data should be saved based on a cycle interval. save_by_cycles (bool): A boolean flag indicating whether the data should be saved based on a cycle interval. cycle_interval (int): The cycle interval for saving the data. ClearHistories() Clears the history of data. SaveParticleInfoAsVTK(particles, file_name) Saves the particle information as a VTK file. particles (list): A list of particles. file_name (string): The name of the file to save. SaveParticleMeshAsVTK(particles, file_name) Saves the particle mesh information as a VTK file. particles (list): A list of particles. file_name (string): The name of the file to save. SaveShapeInfoAsSTL() Saves the shape information as an STL file. SaveShapeInfoAsJson() Saves the shape information as a JSON file. Print() Prints the current configuration of the data dumper. Cast() Casts the Modifier instance to a DataDumper instance. MembraneWall This class represents a wall in a membrane system. Constructor The MembraneWall class has multiple constructors to create a new instance of the class. Each constructor takes a different set of parameters. MembraneWall() Default constructor with no arguments. MembraneWall(double) Constructor with a single argument, the thickness of the wall. MembraneWall(double, double) Constructor with two arguments, the thickness and the bending modulus of the wall. MembraneWall(double, double, double) Constructor with three arguments, the thickness, the bending modulus, and the stretching modulus of the wall. MembraneWall(double, double, double, double, double, double) Constructor with six arguments, the thickness, the bending modulus, the stretching modulus, the repulsion strength, the friction coefficient, and the adhesion energy of the wall. Attributes enable_deformation A boolean flag indicating whether the wall is deformable or not. dump_info A boolean flag indicating whether to dump information about the wall. facing_outside A boolean flag indicating whether the wall is facing outward or inward. wall_list A list of walls. Methods SetRootPath(path) Set the root path for the wall. SetSaveByTime(interval) Set the time interval for saving the wall. SetSaveByCycles(num) Set the number of cycles between saving the wall. Init() Initialize the wall. SetDimensions(nx, ny, nz) Set the dimensions of the wall. SetPressure(pressure) Set the pressure on the wall. Cast() Cast the wall as a MembraneWall object. ParticleGroup This class represents a group of particles. Constructor ParticleGroup() Creates a new instance of the ParticleGroup class. Attributes particle_list A reference to the list of particles in the group. Methods Add(id) Adds a particle to the group. id (int): The ID of the particle to add. Remove(id) Removes a particle from the group. id (int): The ID of the particle to remove. Add(id_list) Adds multiple particles to the group. id_list (list of int): A list of particle IDs to add. Remove(id_list) Removes multiple particles from the group. id_list (list of int): A list of particle IDs to remove. SetVelocity(v) Sets the velocity of all particles in the group. v (Vec3d): The velocity vector to set. SetSpin(w) Sets the spin of all particles in the group. w (Vec3d): The spin vector to set. Clear() Removes all particles from the group. Cast() Casts the Modifier object to a ParticleGroup object. ParticleMotionControl This class represents a modifier that controls the motion of particles. Constructor ParticleMotionControl() Creates a new instance of the ParticleMotionControl class. Methods SetFixed(fixed) Set the particle to be fixed. fixed (bool): A boolean value indicating whether the particle should be fixed or not. SetLinearVelocity(velocity) Set the linear velocity of the particle. velocity (Vec3d): A 3D vector representing the linear velocity of the particle. SetSinVelocity(velocity, frequency) Set the sinusoidal velocity of the particle. velocity (Vec3d): A 3D vector representing the amplitude of the sinusoidal velocity of the particle. frequency (float): The frequency of the sinusoidal velocity. SyncToAllProcessors() Synchronize the state of the particle with all processors. Clear() Clear the state of the particle. Inheritance This class inherits from the Modifier class. WallGroup This class represents a group of walls in the simulation. Inheritance WallGroup inherits from the Modifier class. Constructor WallGroup() Creates a new instance of the WallGroup class. Attributes wall_list A reference to the list of walls in the group. Methods Add(wall_id) Add a wall to the group by ID. wall_id (int): The ID of the wall to add. Remove(wall_id) Remove a wall from the group by ID. wall_id (int): The ID of the wall to remove. Add(wall_ids) Add a list of walls to the group by their IDs. wall_ids (list of int): The IDs of the walls to add. Remove(wall_ids) Remove a list of walls from the group by their IDs. wall_ids (list of int): The IDs of the walls to remove. SetVelocity(vel) Set the velocity of all walls in the group. vel (Vec3d): The velocity to set. SetSpin(spin) Set the spin of all walls in the group. spin (Vec3d): The spin to set. Clear() Remove all walls from the group. Cast() Cast the WallGroup object to a Modifier object. WallDispControl This class represents a modifier that controls the displacement of walls. Constructor WallDispControl() Creates a new instance of the WallDispControl class. Attributes vel The velocity of the walls. spin The spin of the walls. Methods SetVelocity(vel) Sets the velocity of the walls. vel (Vec3d): The velocity to set. SetSpin(spin) Sets the spin of the walls. spin (Vec3d): The spin to set. SetWalls(wall_ids) Sets the walls that this modifier will act on. wall_ids (VecXT or list of int): The IDs of the walls to act on. Cast() Casts the Modifier base class to a WallDispControl object. __init__() The Python constructor for the WallDispControl class. WallMotionIntegrator This class represents a wall motion integrator. Constructor WallMotionIntegrator() Creates a new instance of the WallMotionIntegrator class. Attributes mass The mass of the wall. moi_principal The principal moments of inertia of the wall. enable_translation A boolean indicating whether or not translation of the wall is enabled. enable_rotation A boolean indicating whether or not rotation of the wall is enabled. Methods Cast() Returns a pointer to the WallMotionIntegrator object. SetMass(mass) Sets the mass of the wall. mass (float): The mass to set for the wall. SetMomentOfInertia(principal_moments) Sets the principal moments of inertia of the wall. principal_moments (Vec3d): A 3D vector containing the principal moments of inertia. SetTranslationEnabled(enabled) Sets whether or not translation of the wall is enabled. enabled (bool): Whether or not translation of the wall is enabled. SetRotationEnabled(enabled) Sets whether or not rotation of the wall is enabled. enabled (bool): Whether or not rotation of the wall is enabled. WallServoControl This class represents a wall servo control. Constructor WallServoControl(kn, area) Creates a new instance of the WallServoControl class. kn (float): The spring constant. area (float): The area of the wall. Attributes kn The spring constant of the wall servo control. area The area of the wall servo control. target_pressure The target pressure of the wall servo control. vel_max The maximum velocity of the wall servo control. study_rate The study rate of the wall servo control. tol The tolerance of the wall servo control. enable_warning The flag to enable warnings of the wall servo control. enable_auto_area The flag to enable automatic area of the wall servo control. achieved The achieved flag of the wall servo control. Methods SetWalls(walls) Sets the walls for the wall servo control. walls (list or array of integers): The walls to set. AddWall(wall) Adds a wall to the wall servo control. wall (integer): The wall to add. Cast() Casts the modifier to a WallServoControl object. User manual \u250a Previous \u250a Next","title":"Ref modifier"},{"location":"documentation/ref_modifier/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_modifier/#modifiermanager","text":"This class manages a collection of modifiers that can be enabled or disabled.","title":"ModifierManager"},{"location":"documentation/ref_modifier/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#modifiermanager_1","text":"Creates a new instance of the ModifierManager class.","title":"ModifierManager()"},{"location":"documentation/ref_modifier/#methods","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#insertmodifier","text":"Inserts a modifier into the manager. modifier (Modifier): The modifier to insert.","title":"Insert(modifier)"},{"location":"documentation/ref_modifier/#enablemodifier","text":"Enables a modifier. modifier (Modifier): The modifier to enable.","title":"Enable(modifier)"},{"location":"documentation/ref_modifier/#enablename","text":"Enables a modifier by name. name (string): The name of the modifier to enable.","title":"Enable(name)"},{"location":"documentation/ref_modifier/#disablemodifier","text":"Disables a modifier. modifier (Modifier): The modifier to disable.","title":"Disable(modifier)"},{"location":"documentation/ref_modifier/#disablename","text":"Disables a modifier by name. name (string): The name of the modifier to disable.","title":"Disable(name)"},{"location":"documentation/ref_modifier/#modifier","text":"This class represents a modifier.","title":"Modifier"},{"location":"documentation/ref_modifier/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#modifier_1","text":"Creates a new instance of the Modifier class.","title":"Modifier()"},{"location":"documentation/ref_modifier/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#label","text":"A string label for the modifier.","title":"label"},{"location":"documentation/ref_modifier/#cycle_point","text":"An integer representing the cycle point at which the modifier will be executed.","title":"cycle_point"},{"location":"documentation/ref_modifier/#sim","text":"A pointer to the simulation object associated with the modifier.","title":"sim"},{"location":"documentation/ref_modifier/#scene","text":"A pointer to the scene object associated with the modifier.","title":"scene"},{"location":"documentation/ref_modifier/#update_with_scene","text":"A boolean indicating whether the modifier should update with the scene.","title":"update_with_scene"},{"location":"documentation/ref_modifier/#enable_logging","text":"A boolean indicating whether logging should be enabled for the modifier.","title":"enable_logging"},{"location":"documentation/ref_modifier/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#clone","text":"Creates a new instance of the modifier.","title":"Clone()"},{"location":"documentation/ref_modifier/#init","text":"Initializes the modifier.","title":"Init()"},{"location":"documentation/ref_modifier/#enable","text":"Enables the modifier.","title":"Enable()"},{"location":"documentation/ref_modifier/#disable","text":"Disables the modifier.","title":"Disable()"},{"location":"documentation/ref_modifier/#execute","text":"Executes the modifier.","title":"Execute()"},{"location":"documentation/ref_modifier/#update","text":"Updates the modifier.","title":"Update()"},{"location":"documentation/ref_modifier/#breakageanalysispd","text":"This class represents a breakage analysis for particles in a DEM simulation.","title":"BreakageAnalysisPD"},{"location":"documentation/ref_modifier/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#breakageanalysispd_1","text":"Creates a new instance of the BreakageAnalysisPD class.","title":"BreakageAnalysisPD()"},{"location":"documentation/ref_modifier/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#particle_id_list","text":"A list of particle IDs to include in the breakage analysis.","title":"particle_id_list"},{"location":"documentation/ref_modifier/#use_particles_in_scene","text":"A boolean indicating whether to use all particles in the scene or only the particles in the particle_id_list.","title":"use_particles_in_scene"},{"location":"documentation/ref_modifier/#pd_dem_coupler","text":"An instance of the PdDemCoupler class used to couple the breakage analysis with the DEM simulation.","title":"pd_dem_coupler"},{"location":"documentation/ref_modifier/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setrootpathroot_path","text":"Sets the root path for the breakage analysis output files. root_path (string): The path to the root directory for the output files.","title":"SetRootPath(root_path)"},{"location":"documentation/ref_modifier/#setexecutebytimestart_time-end_time-time_step","text":"Sets the time range and time step for the breakage analysis execution. start_time (float): The start time for the breakage analysis. end_time (float): The end time for the breakage analysis. time_step (float): The time step for the breakage analysis.","title":"SetExecuteByTime(start_time, end_time, time_step)"},{"location":"documentation/ref_modifier/#setexecutebycyclesstart_cycle-end_cycle-cycle_step","text":"Sets the cycle range and cycle step for the breakage analysis execution. start_cycle (int): The start cycle for the breakage analysis. end_cycle (int): The end cycle for the breakage analysis. cycle_step (int): The cycle step for the breakage analysis.","title":"SetExecuteByCycles(start_cycle, end_cycle, cycle_step)"},{"location":"documentation/ref_modifier/#setparticlesfromscene","text":"Sets the particles to include in the breakage analysis based on the particles in the current DEM simulation scene.","title":"SetParticlesFromScene()"},{"location":"documentation/ref_modifier/#setparticlesparticles","text":"Sets the particles to include in the breakage analysis. particles (list of ints or initializer list of ints): The list of particle IDs to include in the breakage analysis.","title":"SetParticles(particles)"},{"location":"documentation/ref_modifier/#cast","text":"Returns a reference to the current instance of the BreakageAnalysisPD class as a Modifier object.","title":"Cast()"},{"location":"documentation/ref_modifier/#datadumper","text":"This class is responsible for dumping data from the simulation to file.","title":"DataDumper"},{"location":"documentation/ref_modifier/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#datadumper_1","text":"Creates a new instance of the DataDumper class.","title":"DataDumper()"},{"location":"documentation/ref_modifier/#attributes_2","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#dump_particle_info","text":"A boolean flag indicating whether particle information should be dumped.","title":"dump_particle_info"},{"location":"documentation/ref_modifier/#dump_wall_info","text":"A boolean flag indicating whether wall information should be dumped.","title":"dump_wall_info"},{"location":"documentation/ref_modifier/#dump_contact_info","text":"A boolean flag indicating whether contact information should be dumped.","title":"dump_contact_info"},{"location":"documentation/ref_modifier/#dump_shape_info","text":"A boolean flag indicating whether shape information should be dumped.","title":"dump_shape_info"},{"location":"documentation/ref_modifier/#dump_mesh","text":"A boolean flag indicating whether mesh information should be dumped.","title":"dump_mesh"},{"location":"documentation/ref_modifier/#dump_reconstructed","text":"A boolean flag indicating whether reconstructed information should be dumped.","title":"dump_reconstructed"},{"location":"documentation/ref_modifier/#time_stamp_adjustable","text":"A boolean flag indicating whether the time stamp is adjustable.","title":"time_stamp_adjustable"},{"location":"documentation/ref_modifier/#methods_3","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setrootpathroot_path_1","text":"Sets the root path where the data will be dumped. root_path (string): The root path where the data will be dumped.","title":"SetRootPath(root_path)"},{"location":"documentation/ref_modifier/#setsavebytimesave_by_time-time_interval","text":"Sets whether the data should be saved based on a time interval. save_by_time (bool): A boolean flag indicating whether the data should be saved based on a time interval. time_interval (float): The time interval for saving the data.","title":"SetSaveByTime(save_by_time, time_interval)"},{"location":"documentation/ref_modifier/#setsavebycyclessave_by_cycles-cycle_interval","text":"Sets whether the data should be saved based on a cycle interval. save_by_cycles (bool): A boolean flag indicating whether the data should be saved based on a cycle interval. cycle_interval (int): The cycle interval for saving the data.","title":"SetSaveByCycles(save_by_cycles, cycle_interval)"},{"location":"documentation/ref_modifier/#clearhistories","text":"Clears the history of data.","title":"ClearHistories()"},{"location":"documentation/ref_modifier/#saveparticleinfoasvtkparticles-file_name","text":"Saves the particle information as a VTK file. particles (list): A list of particles. file_name (string): The name of the file to save.","title":"SaveParticleInfoAsVTK(particles, file_name)"},{"location":"documentation/ref_modifier/#saveparticlemeshasvtkparticles-file_name","text":"Saves the particle mesh information as a VTK file. particles (list): A list of particles. file_name (string): The name of the file to save.","title":"SaveParticleMeshAsVTK(particles, file_name)"},{"location":"documentation/ref_modifier/#saveshapeinfoasstl","text":"Saves the shape information as an STL file.","title":"SaveShapeInfoAsSTL()"},{"location":"documentation/ref_modifier/#saveshapeinfoasjson","text":"Saves the shape information as a JSON file.","title":"SaveShapeInfoAsJson()"},{"location":"documentation/ref_modifier/#print","text":"Prints the current configuration of the data dumper.","title":"Print()"},{"location":"documentation/ref_modifier/#cast_1","text":"Casts the Modifier instance to a DataDumper instance.","title":"Cast()"},{"location":"documentation/ref_modifier/#membranewall","text":"This class represents a wall in a membrane system.","title":"MembraneWall"},{"location":"documentation/ref_modifier/#constructor_4","text":"The MembraneWall class has multiple constructors to create a new instance of the class. Each constructor takes a different set of parameters.","title":"Constructor"},{"location":"documentation/ref_modifier/#membranewall_1","text":"Default constructor with no arguments.","title":"MembraneWall()"},{"location":"documentation/ref_modifier/#membranewalldouble","text":"Constructor with a single argument, the thickness of the wall.","title":"MembraneWall(double)"},{"location":"documentation/ref_modifier/#membranewalldouble-double","text":"Constructor with two arguments, the thickness and the bending modulus of the wall.","title":"MembraneWall(double, double)"},{"location":"documentation/ref_modifier/#membranewalldouble-double-double","text":"Constructor with three arguments, the thickness, the bending modulus, and the stretching modulus of the wall.","title":"MembraneWall(double, double, double)"},{"location":"documentation/ref_modifier/#membranewalldouble-double-double-double-double-double","text":"Constructor with six arguments, the thickness, the bending modulus, the stretching modulus, the repulsion strength, the friction coefficient, and the adhesion energy of the wall.","title":"MembraneWall(double, double, double, double, double, double)"},{"location":"documentation/ref_modifier/#attributes_3","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#enable_deformation","text":"A boolean flag indicating whether the wall is deformable or not.","title":"enable_deformation"},{"location":"documentation/ref_modifier/#dump_info","text":"A boolean flag indicating whether to dump information about the wall.","title":"dump_info"},{"location":"documentation/ref_modifier/#facing_outside","text":"A boolean flag indicating whether the wall is facing outward or inward.","title":"facing_outside"},{"location":"documentation/ref_modifier/#wall_list","text":"A list of walls.","title":"wall_list"},{"location":"documentation/ref_modifier/#methods_4","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setrootpathpath","text":"Set the root path for the wall.","title":"SetRootPath(path)"},{"location":"documentation/ref_modifier/#setsavebytimeinterval","text":"Set the time interval for saving the wall.","title":"SetSaveByTime(interval)"},{"location":"documentation/ref_modifier/#setsavebycyclesnum","text":"Set the number of cycles between saving the wall.","title":"SetSaveByCycles(num)"},{"location":"documentation/ref_modifier/#init_1","text":"Initialize the wall.","title":"Init()"},{"location":"documentation/ref_modifier/#setdimensionsnx-ny-nz","text":"Set the dimensions of the wall.","title":"SetDimensions(nx, ny, nz)"},{"location":"documentation/ref_modifier/#setpressurepressure","text":"Set the pressure on the wall.","title":"SetPressure(pressure)"},{"location":"documentation/ref_modifier/#cast_2","text":"Cast the wall as a MembraneWall object.","title":"Cast()"},{"location":"documentation/ref_modifier/#particlegroup","text":"This class represents a group of particles.","title":"ParticleGroup"},{"location":"documentation/ref_modifier/#constructor_5","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#particlegroup_1","text":"Creates a new instance of the ParticleGroup class.","title":"ParticleGroup()"},{"location":"documentation/ref_modifier/#attributes_4","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#particle_list","text":"A reference to the list of particles in the group.","title":"particle_list"},{"location":"documentation/ref_modifier/#methods_5","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#addid","text":"Adds a particle to the group. id (int): The ID of the particle to add.","title":"Add(id)"},{"location":"documentation/ref_modifier/#removeid","text":"Removes a particle from the group. id (int): The ID of the particle to remove.","title":"Remove(id)"},{"location":"documentation/ref_modifier/#addid_list","text":"Adds multiple particles to the group. id_list (list of int): A list of particle IDs to add.","title":"Add(id_list)"},{"location":"documentation/ref_modifier/#removeid_list","text":"Removes multiple particles from the group. id_list (list of int): A list of particle IDs to remove.","title":"Remove(id_list)"},{"location":"documentation/ref_modifier/#setvelocityv","text":"Sets the velocity of all particles in the group. v (Vec3d): The velocity vector to set.","title":"SetVelocity(v)"},{"location":"documentation/ref_modifier/#setspinw","text":"Sets the spin of all particles in the group. w (Vec3d): The spin vector to set.","title":"SetSpin(w)"},{"location":"documentation/ref_modifier/#clear","text":"Removes all particles from the group.","title":"Clear()"},{"location":"documentation/ref_modifier/#cast_3","text":"Casts the Modifier object to a ParticleGroup object.","title":"Cast()"},{"location":"documentation/ref_modifier/#particlemotioncontrol","text":"This class represents a modifier that controls the motion of particles.","title":"ParticleMotionControl"},{"location":"documentation/ref_modifier/#constructor_6","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#particlemotioncontrol_1","text":"Creates a new instance of the ParticleMotionControl class.","title":"ParticleMotionControl()"},{"location":"documentation/ref_modifier/#methods_6","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setfixedfixed","text":"Set the particle to be fixed. fixed (bool): A boolean value indicating whether the particle should be fixed or not.","title":"SetFixed(fixed)"},{"location":"documentation/ref_modifier/#setlinearvelocityvelocity","text":"Set the linear velocity of the particle. velocity (Vec3d): A 3D vector representing the linear velocity of the particle.","title":"SetLinearVelocity(velocity)"},{"location":"documentation/ref_modifier/#setsinvelocityvelocity-frequency","text":"Set the sinusoidal velocity of the particle. velocity (Vec3d): A 3D vector representing the amplitude of the sinusoidal velocity of the particle. frequency (float): The frequency of the sinusoidal velocity.","title":"SetSinVelocity(velocity, frequency)"},{"location":"documentation/ref_modifier/#synctoallprocessors","text":"Synchronize the state of the particle with all processors.","title":"SyncToAllProcessors()"},{"location":"documentation/ref_modifier/#clear_1","text":"Clear the state of the particle.","title":"Clear()"},{"location":"documentation/ref_modifier/#inheritance","text":"This class inherits from the Modifier class.","title":"Inheritance"},{"location":"documentation/ref_modifier/#wallgroup","text":"This class represents a group of walls in the simulation.","title":"WallGroup"},{"location":"documentation/ref_modifier/#inheritance_1","text":"WallGroup inherits from the Modifier class.","title":"Inheritance"},{"location":"documentation/ref_modifier/#constructor_7","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#wallgroup_1","text":"Creates a new instance of the WallGroup class.","title":"WallGroup()"},{"location":"documentation/ref_modifier/#attributes_5","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#wall_list_1","text":"A reference to the list of walls in the group.","title":"wall_list"},{"location":"documentation/ref_modifier/#methods_7","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#addwall_id","text":"Add a wall to the group by ID. wall_id (int): The ID of the wall to add.","title":"Add(wall_id)"},{"location":"documentation/ref_modifier/#removewall_id","text":"Remove a wall from the group by ID. wall_id (int): The ID of the wall to remove.","title":"Remove(wall_id)"},{"location":"documentation/ref_modifier/#addwall_ids","text":"Add a list of walls to the group by their IDs. wall_ids (list of int): The IDs of the walls to add.","title":"Add(wall_ids)"},{"location":"documentation/ref_modifier/#removewall_ids","text":"Remove a list of walls from the group by their IDs. wall_ids (list of int): The IDs of the walls to remove.","title":"Remove(wall_ids)"},{"location":"documentation/ref_modifier/#setvelocityvel","text":"Set the velocity of all walls in the group. vel (Vec3d): The velocity to set.","title":"SetVelocity(vel)"},{"location":"documentation/ref_modifier/#setspinspin","text":"Set the spin of all walls in the group. spin (Vec3d): The spin to set.","title":"SetSpin(spin)"},{"location":"documentation/ref_modifier/#clear_2","text":"Remove all walls from the group.","title":"Clear()"},{"location":"documentation/ref_modifier/#cast_4","text":"Cast the WallGroup object to a Modifier object.","title":"Cast()"},{"location":"documentation/ref_modifier/#walldispcontrol","text":"This class represents a modifier that controls the displacement of walls.","title":"WallDispControl"},{"location":"documentation/ref_modifier/#constructor_8","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#walldispcontrol_1","text":"Creates a new instance of the WallDispControl class.","title":"WallDispControl()"},{"location":"documentation/ref_modifier/#attributes_6","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#vel","text":"The velocity of the walls.","title":"vel"},{"location":"documentation/ref_modifier/#spin","text":"The spin of the walls.","title":"spin"},{"location":"documentation/ref_modifier/#methods_8","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setvelocityvel_1","text":"Sets the velocity of the walls. vel (Vec3d): The velocity to set.","title":"SetVelocity(vel)"},{"location":"documentation/ref_modifier/#setspinspin_1","text":"Sets the spin of the walls. spin (Vec3d): The spin to set.","title":"SetSpin(spin)"},{"location":"documentation/ref_modifier/#setwallswall_ids","text":"Sets the walls that this modifier will act on.","title":"SetWalls(wall_ids)"},{"location":"documentation/ref_modifier/#wall_ids-vecxt-or-list-of-int-the-ids-of-the-walls-to-act-on","text":"","title":"wall_ids (VecXT or list of int): The IDs of the walls to act on."},{"location":"documentation/ref_modifier/#cast_5","text":"Casts the Modifier base class to a WallDispControl object.","title":"Cast()"},{"location":"documentation/ref_modifier/#__init__","text":"The Python constructor for the WallDispControl class.","title":"__init__()"},{"location":"documentation/ref_modifier/#wallmotionintegrator","text":"This class represents a wall motion integrator.","title":"WallMotionIntegrator"},{"location":"documentation/ref_modifier/#constructor_9","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#wallmotionintegrator_1","text":"Creates a new instance of the WallMotionIntegrator class.","title":"WallMotionIntegrator()"},{"location":"documentation/ref_modifier/#attributes_7","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#mass","text":"The mass of the wall.","title":"mass"},{"location":"documentation/ref_modifier/#moi_principal","text":"The principal moments of inertia of the wall.","title":"moi_principal"},{"location":"documentation/ref_modifier/#enable_translation","text":"A boolean indicating whether or not translation of the wall is enabled.","title":"enable_translation"},{"location":"documentation/ref_modifier/#enable_rotation","text":"A boolean indicating whether or not rotation of the wall is enabled.","title":"enable_rotation"},{"location":"documentation/ref_modifier/#methods_9","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#cast_6","text":"Returns a pointer to the WallMotionIntegrator object.","title":"Cast()"},{"location":"documentation/ref_modifier/#setmassmass","text":"Sets the mass of the wall. mass (float): The mass to set for the wall.","title":"SetMass(mass)"},{"location":"documentation/ref_modifier/#setmomentofinertiaprincipal_moments","text":"Sets the principal moments of inertia of the wall. principal_moments (Vec3d): A 3D vector containing the principal moments of inertia.","title":"SetMomentOfInertia(principal_moments)"},{"location":"documentation/ref_modifier/#settranslationenabledenabled","text":"Sets whether or not translation of the wall is enabled. enabled (bool): Whether or not translation of the wall is enabled.","title":"SetTranslationEnabled(enabled)"},{"location":"documentation/ref_modifier/#setrotationenabledenabled","text":"Sets whether or not rotation of the wall is enabled. enabled (bool): Whether or not rotation of the wall is enabled.","title":"SetRotationEnabled(enabled)"},{"location":"documentation/ref_modifier/#wallservocontrol","text":"This class represents a wall servo control.","title":"WallServoControl"},{"location":"documentation/ref_modifier/#constructor_10","text":"","title":"Constructor"},{"location":"documentation/ref_modifier/#wallservocontrolkn-area","text":"Creates a new instance of the WallServoControl class. kn (float): The spring constant. area (float): The area of the wall.","title":"WallServoControl(kn, area)"},{"location":"documentation/ref_modifier/#attributes_8","text":"","title":"Attributes"},{"location":"documentation/ref_modifier/#kn","text":"The spring constant of the wall servo control.","title":"kn"},{"location":"documentation/ref_modifier/#area","text":"The area of the wall servo control.","title":"area"},{"location":"documentation/ref_modifier/#target_pressure","text":"The target pressure of the wall servo control.","title":"target_pressure"},{"location":"documentation/ref_modifier/#vel_max","text":"The maximum velocity of the wall servo control.","title":"vel_max"},{"location":"documentation/ref_modifier/#study_rate","text":"The study rate of the wall servo control.","title":"study_rate"},{"location":"documentation/ref_modifier/#tol","text":"The tolerance of the wall servo control.","title":"tol"},{"location":"documentation/ref_modifier/#enable_warning","text":"The flag to enable warnings of the wall servo control.","title":"enable_warning"},{"location":"documentation/ref_modifier/#enable_auto_area","text":"The flag to enable automatic area of the wall servo control.","title":"enable_auto_area"},{"location":"documentation/ref_modifier/#achieved","text":"The achieved flag of the wall servo control.","title":"achieved"},{"location":"documentation/ref_modifier/#methods_10","text":"","title":"Methods"},{"location":"documentation/ref_modifier/#setwallswalls","text":"Sets the walls for the wall servo control. walls (list or array of integers): The walls to set.","title":"SetWalls(walls)"},{"location":"documentation/ref_modifier/#addwallwall","text":"Adds a wall to the wall servo control. wall (integer): The wall to add.","title":"AddWall(wall)"},{"location":"documentation/ref_modifier/#cast_7","text":"Casts the modifier to a WallServoControl object. User manual \u250a Previous \u250a Next","title":"Cast()"},{"location":"documentation/ref_mpi/","text":"User manual \u250a Previous \u250a Next MPIManager This class provides an interface for MPI-based parallelism. Constructor MPIManager() Creates a new instance of the MPIManager class. Methods GetSelfRank() Returns the rank of the current process. GetTotalRank() Returns the total number of processes. SyncShapeToAllProcessors(shape) Synchronizes the shape of an array among all the processes. shape (numpy array): A numpy array that represents the shape to synchronize. SyncDataAmongProcessors(data) Synchronizes the data of an array among all the processes. data (numpy array): A numpy array that represents the data to synchronize. Note: This method can be called with either an array of integers or an array of doubles. User manual \u250a Previous \u250a Next","title":"Ref mpi"},{"location":"documentation/ref_mpi/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_mpi/#mpimanager","text":"This class provides an interface for MPI-based parallelism.","title":"MPIManager"},{"location":"documentation/ref_mpi/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_mpi/#mpimanager_1","text":"Creates a new instance of the MPIManager class.","title":"MPIManager()"},{"location":"documentation/ref_mpi/#methods","text":"","title":"Methods"},{"location":"documentation/ref_mpi/#getselfrank","text":"Returns the rank of the current process.","title":"GetSelfRank()"},{"location":"documentation/ref_mpi/#gettotalrank","text":"Returns the total number of processes.","title":"GetTotalRank()"},{"location":"documentation/ref_mpi/#syncshapetoallprocessorsshape","text":"Synchronizes the shape of an array among all the processes. shape (numpy array): A numpy array that represents the shape to synchronize.","title":"SyncShapeToAllProcessors(shape)"},{"location":"documentation/ref_mpi/#syncdataamongprocessorsdata","text":"Synchronizes the data of an array among all the processes. data (numpy array): A numpy array that represents the data to synchronize. Note: This method can be called with either an array of integers or an array of doubles. User manual \u250a Previous \u250a Next","title":"SyncDataAmongProcessors(data)"},{"location":"documentation/ref_netdem/","text":"User manual \u250a Previous \u250a Next PyNetDEM PyNetDEM is a Python interface for NetDEM. Modules PyNetDEM is composed of several modules that can be imported separately. pynetdem.utils : Contains utility functions used across all other modules. pynetdem.fem : Contains functions related to Finite Element Method. pynetdem.dem : Contains functions related to Discrete Element Method. pynetdem.domain : Contains functions related to domain creation and modification. pynetdem.peridigm : Contains functions related to PeriDEM. pynetdem.shape : Contains functions related to shape creation and modification. pynetdem.scene : Contains functions related to scene creation and modification. pynetdem.modifier : Contains functions related to modifier creation and modification. pynetdem.mpi : Contains functions related to MPI management. pynetdem.simulation : Contains functions related to simulation creation and management. User manual \u250a Previous \u250a Next","title":"Ref netdem"},{"location":"documentation/ref_netdem/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_netdem/#pynetdem","text":"PyNetDEM is a Python interface for NetDEM.","title":"PyNetDEM"},{"location":"documentation/ref_netdem/#modules","text":"PyNetDEM is composed of several modules that can be imported separately. pynetdem.utils : Contains utility functions used across all other modules. pynetdem.fem : Contains functions related to Finite Element Method. pynetdem.dem : Contains functions related to Discrete Element Method. pynetdem.domain : Contains functions related to domain creation and modification. pynetdem.peridigm : Contains functions related to PeriDEM. pynetdem.shape : Contains functions related to shape creation and modification. pynetdem.scene : Contains functions related to scene creation and modification. pynetdem.modifier : Contains functions related to modifier creation and modification. pynetdem.mpi : Contains functions related to MPI management. pynetdem.simulation : Contains functions related to simulation creation and management. User manual \u250a Previous \u250a Next","title":"Modules"},{"location":"documentation/ref_peridigm/","text":"User manual \u250a Previous \u250a Next Peridigm DomainSplittor This class represents a domain splittor. Constructor DomainSplittor() Creates a new instance of the DomainSplittor class. Methods InitFromSTL(filename, num_parts) Initializes the domain splittor from an STL file. filename (string): The name of the STL file to read. num_parts (int): The number of parts to split the domain into. LevelSetSplittor This class represents a level set splittor, which is a type of domain splittor. Constructor LevelSetSplittor() Creates a new instance of the LevelSetSplittor class. Methods InitFromDistanceMap(filename) Initializes the level set splittor from a distance map file. filename (string): The name of the distance map file to read. InitFromDistanceMap (x_min, x_max, y_min, y_max, z_min, z_max, num_parts, distance_map) Initializes the level set splittor from a distance map. x_min (double): The minimum x coordinate of the domain. x_max (double): The maximum x coordinate of the domain. y_min (double): The minimum y coordinate of the domain. y_max (double): The maximum y coordinate of the domain. z_min (double): The minimum z coordinate of the domain. z_max (double): The maximum z coordinate of the domain. num_parts (int): The number of parts to split the domain into. distance_map (VecXT ): A vector containing the distance map data. InitFromSTL(stl_model, num_parts) Initializes the level set splittor from an STL model. stl_model (STLModel): The STL model to initialize from. num_parts (int): The number of parts to split the domain into. GetPeriDigmNodes() Returns the Peridigm node data for the domain. MakePorosity(radius) Adds porosity to the domain. radius (double): The radius of the porosity. GetSTLModel() Returns the STL model for the domain. GetSTLModel(part_ids) Returns the STL model for a specific set of domain parts. part_ids (VecXT ): A vector containing the IDs of the domain parts to include in the model. TetMeshSplittor This class represents a tetrahedral mesh splittor. Constructor TetMeshSplittor() Creates a new instance of the TetMeshSplittor class. Methods InitFromSTL(stl_model, num_partitions) Initialize the tetrahedral mesh splittor from an STL model. stl_model (STLModel): The STL model to use for initialization. num_partitions (int): The number of partitions to split the mesh into. GetPeriDigmNodes() Get the Peridigm nodes. MakePorosity() Make porosity in the mesh. GetSTLModel() Get the STL model. Returns a VecXT object representing the STL model. `GetSTLModel(node_id) Get the STL model. node_id (VecXT ): The node ID to get the STL model for. Returns a VecXT object representing the STL model for the specified node ID. PeriDigmDiscretization This class represents a discretization of a PeriDigm model. Constructor PeriDigmDiscretization() Creates a new instance of the PeriDigmDiscretization class. Attributes type An enumeration that specifies the type of the discretization. Possible values are: level_set a level set discretization tetmesh a tetrahedral mesh discretization domain_splittor The domain splittor used to split the domain into blocks. nodes The nodes of the discretization. node_block_indices The block indices of the nodes. node_vols The volumes of the nodes. Methods InitFromSTL(stl_file_path, num_partitions) Initialize the discretization from an STL file. stl_file_path (string): The path to the STL file. num_partitions (int): The number of partitions to split the domain into. InitFromSTL(stl_model, num_partitions) Initialize the discretization from an STL model. stl_model (STLModel): The STL model to use. num_partitions (int): The number of partitions to split the domain into. InitFromDistanceMap(distance_map_file_path, num_partitions) Initialize the discretization from a distance map file. distance_map_file_path (string): The path to the distance map file. num_partitions (int): The number of partitions to split the domain into. InitFromGrid(grid_file_path, num_partitions) Initialize the discretization from a grid file. grid_file_path (string): The path to the grid file. num_partitions (int): The number of partitions to split the domain into. MakePorosity(porosity) Add porosity to the discretization. porosity (float): The porosity to add. WriteInputFile(node_file_path) Write the input file of the discretization. node_file_path (string): The path to write the node file. GetNodeSize() Get the size of the nodes in the discretization. PeriDigmDiscretization This class represents a PeriDigm discretization. Constructor PeriDigmDiscretization() Creates a new instance of the PeriDigmDiscretization class. Enum Type An enum class for different types of PeriDigm discretization. The available values are: level_set tetmesh Attributes type A Type value representing the type of PeriDigm discretization. domain_splittor The domain splitter for the PeriDigm discretization. nodes A vector of Node objects representing the nodes of the PeriDigm discretization. node_block_indices A vector of int values representing the block indices of the nodes. node_vols A vector of double values representing the volumes of the nodes. Methods InitFromSTL(filename, numBlocks) Initialize the PeriDigm discretization from an STL file. filename (string): The filename of the STL file to load. numBlocks (int): The number of blocks to create. InitFromSTL(stl_model, numBlocks) Initialize the PeriDigm discretization from an STL model. stl_model (STLModel): The STL model to use for initialization. numBlocks (int): The number of blocks to create. InitFromDistanceMap(distanceMap, numBlocks) Initialize the PeriDigm discretization from a distance map. distanceMap (DistanceMap): The distance map to use for initialization. numBlocks (int): The number of blocks to create. InitFromGrid(grid, numBlocks) Initialize the PeriDigm discretization from a grid. grid (Grid): The grid to use for initialization. numBlocks (int): The number of blocks to create. MakePorosity(porosity) Set the porosity of the PeriDigm discretization. porosity (double): The porosity to set. WriteInputFile(filename) Write the PeriDigm discretization to a file. filename (string): The filename to write to. GetNodeSize() Return the size of the nodes in the PeriDigm discretization. PeriDigmMaterial This class represents a material model in PeriDigm. Constructor PeriDigmMaterial() Creates a new instance of the PeriDigmMaterial class. Attributes type An enum value that represents the type of material. The possible values are: Elastic density The density of the material. youngs_modulus The Young's modulus of the material. poissons_ratio The Poisson's ratio of the material. Methods WriteInputFile(filename) Writes the material properties to an input file. filename (string): The name of the file to write to. PeriDigmDamageModel This class represents a damage model in the PeriDigm library. Constructor PeriDigmDamageModel() Creates a new instance of the PeriDigmDamageModel class. Attributes type A string representing the type of the damage model. critical_stretch A double representing the critical stretch for the damage model. Methods InitFromEnergyReleaseRate(energy_release_rate) Initializes the damage model based on the energy release rate. energy_release_rate (double): The energy release rate. GetStretchFromEnergyReleaseRate(energy_release_rate) Returns the stretch based on the energy release rate. energy_release_rate (double): The energy release rate. WriteInputFile(file_name) Writes the input file for the damage model. file_name (string): The name of the input file to write. PeriDigmBlock This class represents a block in a PeriDigm simulation. Constructor PeriDigmBlock() Creates a new instance of the PeriDigmBlock class. Attributes node_indices A list of the node indices that make up the block. material_id An integer ID for the material that the block is composed of. damage_model_id An integer ID for the damage model used to simulate damage in the block. horizon The horizon used in the simulation. Methods WriteInputFile(file_name) Writes the block information to an input file. file_name (string): The name of the file to write to. PeriDigmBoundaryCondition This class represents a boundary condition in the PeriDigm code. Constructor PeriDigmBoundaryCondition() Creates a new instance of the PeriDigmBoundaryCondition class. Attributes type An enum that specifies the type of boundary condition. The possible values are: Prescribed_Displacement The boundary condition is specified by a prescribed displacement. Body_Force The boundary condition is specified by a body force. node_indices A list of integers that specify the indices of the nodes that the boundary condition applies to. dim_activated A list of integers that specify the dimensions that the boundary condition is activated in. The possible values are 0, 1, and 2, which correspond to the x, y, and z directions, respectively. disp_rate A float that specifies the rate of displacement for the boundary condition. loading_rate A float that specifies the rate of loading for the boundary condition. disp A float that specifies the displacement for the boundary condition. loading A float that specifies the loading for the boundary condition. mech_time A float that specifies the mechanical time for the boundary condition. Methods InsertNode(node_index) Insert a node into the list of nodes that the boundary condition applies to. node_index (int): The index of the node to insert. SetActivatedDimensions(dimensions) Set the dimensions that the boundary condition is activated in. dimensions (list of int): A list of integers that specify the dimensions that the boundary condition is activated in. SetByDisplacementRate(rate) Set the boundary condition by a prescribed displacement rate. rate (float): The rate of displacement to use. SetByLoadingRate(rate) Set the boundary condition by a prescribed loading rate. rate (float): The rate of loading to use. SetByUltimateDisplacement(displacement) Set the boundary condition by a prescribed ultimate displacement. displacement (float): The ultimate displacement to use. SetByUltimateLoading(loading) Set the boundary condition by a prescribed ultimate loading. loading (float): The ultimate loading to use. WriteInputFile(filename) Write the boundary condition to an input file. filename (string): The name of the file to write to. PeriDigmSettings This class represents the settings for the PeriDigm code. Constructor PeriDigmSettings() Creates a new instance of the PeriDigmSettings class. Attributes result_dir A string representing the directory where the simulation results are stored. peridigm_exe A string representing the path to the PeriDigm executable. horizon_factor A float representing the factor used to determine the horizon for each particle. use_auto_timestep A boolean indicating whether to use an automatic time step or not. timestep A float representing the time step size to be used. timestep_factor A float representing the factor used to determine the time step size for each particle. mech_time A float representing the total mechanical time of the simulation. loading_radius_factor A float representing the factor used to determine the loading radius for each particle. constrain_radius_factor A float representing the factor used to determine the constrain radius for each particle. output_freqency An integer representing the frequency of output data. Methods WriteInputFile(input_file_path) Writes the input file for the PeriDigm code. input_file_path (string): The path to the input file to write. DEMFragment This class represents a discrete element method (DEM) fragment. Constructor DEMFragment() Creates a new instance of the DEMFragment class. Attributes shape_type An integer that represents the shape type of the fragment. sphere_size A float that represents the sphere size of the fragment. stl_model A STLModel object that represents the STL model of the fragment. vel A Vec3d object that represents the velocity of the fragment. spin A Vec3d object that represents the spin of the fragment. Methods InitLevelSet(level_set) Applies a boundary force to the fragment based on the given level set. level_set (LevelSet): A level set that represents the boundary. ResolverOverlap(other_frag) Resolves the overlap between this fragment and another fragment. other_frag (DEMFragment): The other fragment to resolve the overlap with. ReInitSTLModel() Re-initializes the STL model of the fragment. ParticleStrengthParameters This class represents the strength parameters of a particle. Constructor ParticleStrengthParameters() Creates a new instance of the ParticleStrengthParameters class. Attributes ref_size The reference size of the particle. ref_energy_release_rate The reference energy release rate of the particle. weibull_modulus The Weibull modulus of the particle. weibull_coef_a The Weibull coefficient A of the particle. weibull_coef_b The Weibull coefficient B of the particle. min_breakable_size The minimum breakable size of the particle. Methods GetEnergyReleaseRate(size) Calculates the energy release rate of the particle for a given size. size (float): The size of the particle. GetEnergyReleaseRate(size, strength) Calculates the energy release rate of the particle for a given size and strength. size (float): The size of the particle. strength (float): The strength of the particle. PeriDigmSimulator This class represents a PeriDigm simulator. Constructor PeriDigmSimulator() Creates a new instance of the PeriDigmSimulator class. Attributes discretization The discretization used in the simulation. materials The materials used in the simulation. damage_models The damage models used in the simulation. blocks The blocks used in the simulation. boundary_conditions The boundary conditions used in the simulation. settings The settings used in the simulation. Methods Clear() Clears all data associated with the simulator. InsertMaterial(material) Inserts a material into the simulator. material (Material): The material to insert. InsertDamageModel(damage_model) Inserts a damage model into the simulator. damage_model (DamageModel): The damage model to insert. InsertBlock(block) Inserts a block into the simulator. block (Block): The block to insert. InsertBoundaryCondition(boundary_condition) Inserts a boundary condition into the simulator. boundary_condition (BoundaryCondition): The boundary condition to insert. InitDefaultSetup() Initializes the simulator with default settings. InitAutoTimestep() Initializes the simulator with automatic timestep settings. WriteNodeFile() Writes the node file for the simulator. WriteNodeSetFile() Writes the node set file for the simulator. WriteInputFile() Writes the input file for the simulator. Solve() Runs the simulation. SetUpResultDirectory() Sets up the result directory for the simulation. CleanUpResultDirectory() Cleans up the result directory for the simulation. PeriDigmDEMCoupler This class represents a coupler between the Peridynamics and DEM models. Constructor PeriDigmDEMCoupler() Creates a new instance of the PeriDigmDEMCoupler class. Attributes particle The Peridynamics particle system. pd_sim The Peridynamics simulation. base_dir The base directory for output files. sub_dir_index The sub-directory index for output files. mesh_res The resolution of the DEM mesh. node_size_ave The average size of the DEM mesh nodes. mech_time The mechanical time step size. surface_stl The path to the STL file representing the surface of the simulation domain. boundary_force_nodes The nodes on the boundary where forces are applied. boundary_force_node_vols The volumes associated with the boundary force nodes. boundary_force_values The values of the boundary forces. unbalanced_force_nodes The nodes where unbalanced forces are applied. unbalanced_force_values The values of the unbalanced forces. use_customized_loading_rate A flag indicating whether to use a customized loading rate. loading_rate The loading rate. loading_steps The number of loading steps. is_broken A flag indicating whether the material is broken. damage_fraction_limit The damage fraction limit. fragment_vol_limit The fragment volume limit. ignore_fines A flag indicating whether to ignore fines. use_alpha_shape A flag indicating whether to use alpha shape. fragment_alpha The alpha value for fragmenting. strength_params The strength parameters. material_params The material parameters. Methods Init() Initializes the DEM coupler. ApplyBoundaryForce() Applies the boundary forces. Solve() Solves the DEM coupler. CheckBreakage() Checks for breakage. GetFragments() Gets the fragments. User manual \u250a Previous \u250a Next","title":"Ref peridigm"},{"location":"documentation/ref_peridigm/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_peridigm/#peridigm","text":"","title":"Peridigm"},{"location":"documentation/ref_peridigm/#domainsplittor","text":"This class represents a domain splittor.","title":"DomainSplittor"},{"location":"documentation/ref_peridigm/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#domainsplittor_1","text":"Creates a new instance of the DomainSplittor class.","title":"DomainSplittor()"},{"location":"documentation/ref_peridigm/#methods","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromstlfilename-num_parts","text":"Initializes the domain splittor from an STL file. filename (string): The name of the STL file to read. num_parts (int): The number of parts to split the domain into.","title":"InitFromSTL(filename, num_parts)"},{"location":"documentation/ref_peridigm/#levelsetsplittor","text":"This class represents a level set splittor, which is a type of domain splittor.","title":"LevelSetSplittor"},{"location":"documentation/ref_peridigm/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#levelsetsplittor_1","text":"Creates a new instance of the LevelSetSplittor class.","title":"LevelSetSplittor()"},{"location":"documentation/ref_peridigm/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromdistancemapfilename","text":"Initializes the level set splittor from a distance map file. filename (string): The name of the distance map file to read.","title":"InitFromDistanceMap(filename)"},{"location":"documentation/ref_peridigm/#initfromdistancemap-x_min-x_max-y_min-y_max-z_min-z_max-num_parts-distance_map","text":"Initializes the level set splittor from a distance map. x_min (double): The minimum x coordinate of the domain. x_max (double): The maximum x coordinate of the domain. y_min (double): The minimum y coordinate of the domain. y_max (double): The maximum y coordinate of the domain. z_min (double): The minimum z coordinate of the domain. z_max (double): The maximum z coordinate of the domain. num_parts (int): The number of parts to split the domain into. distance_map (VecXT ): A vector containing the distance map data.","title":"InitFromDistanceMap (x_min, x_max, y_min, y_max, z_min, z_max, num_parts, distance_map)"},{"location":"documentation/ref_peridigm/#initfromstlstl_model-num_parts","text":"Initializes the level set splittor from an STL model. stl_model (STLModel): The STL model to initialize from. num_parts (int): The number of parts to split the domain into.","title":"InitFromSTL(stl_model, num_parts)"},{"location":"documentation/ref_peridigm/#getperidigmnodes","text":"Returns the Peridigm node data for the domain.","title":"GetPeriDigmNodes()"},{"location":"documentation/ref_peridigm/#makeporosityradius","text":"Adds porosity to the domain. radius (double): The radius of the porosity.","title":"MakePorosity(radius)"},{"location":"documentation/ref_peridigm/#getstlmodel","text":"Returns the STL model for the domain.","title":"GetSTLModel()"},{"location":"documentation/ref_peridigm/#getstlmodelpart_ids","text":"Returns the STL model for a specific set of domain parts. part_ids (VecXT ): A vector containing the IDs of the domain parts to include in the model.","title":"GetSTLModel(part_ids)"},{"location":"documentation/ref_peridigm/#tetmeshsplittor","text":"This class represents a tetrahedral mesh splittor.","title":"TetMeshSplittor"},{"location":"documentation/ref_peridigm/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#tetmeshsplittor_1","text":"Creates a new instance of the TetMeshSplittor class.","title":"TetMeshSplittor()"},{"location":"documentation/ref_peridigm/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromstlstl_model-num_partitions","text":"Initialize the tetrahedral mesh splittor from an STL model. stl_model (STLModel): The STL model to use for initialization. num_partitions (int): The number of partitions to split the mesh into.","title":"InitFromSTL(stl_model, num_partitions)"},{"location":"documentation/ref_peridigm/#getperidigmnodes_1","text":"Get the Peridigm nodes.","title":"GetPeriDigmNodes()"},{"location":"documentation/ref_peridigm/#makeporosity","text":"Make porosity in the mesh.","title":"MakePorosity()"},{"location":"documentation/ref_peridigm/#getstlmodel_1","text":"Get the STL model. Returns a VecXT object representing the STL model.","title":"GetSTLModel()"},{"location":"documentation/ref_peridigm/#getstlmodelnode_id","text":"Get the STL model. node_id (VecXT ): The node ID to get the STL model for. Returns a VecXT object representing the STL model for the specified node ID.","title":"`GetSTLModel(node_id)"},{"location":"documentation/ref_peridigm/#peridigmdiscretization","text":"This class represents a discretization of a PeriDigm model.","title":"PeriDigmDiscretization"},{"location":"documentation/ref_peridigm/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmdiscretization_1","text":"Creates a new instance of the PeriDigmDiscretization class.","title":"PeriDigmDiscretization()"},{"location":"documentation/ref_peridigm/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#type","text":"An enumeration that specifies the type of the discretization. Possible values are:","title":"type"},{"location":"documentation/ref_peridigm/#level_set","text":"a level set discretization","title":"level_set"},{"location":"documentation/ref_peridigm/#tetmesh","text":"a tetrahedral mesh discretization","title":"tetmesh"},{"location":"documentation/ref_peridigm/#domain_splittor","text":"The domain splittor used to split the domain into blocks.","title":"domain_splittor"},{"location":"documentation/ref_peridigm/#nodes","text":"The nodes of the discretization.","title":"nodes"},{"location":"documentation/ref_peridigm/#node_block_indices","text":"The block indices of the nodes.","title":"node_block_indices"},{"location":"documentation/ref_peridigm/#node_vols","text":"The volumes of the nodes.","title":"node_vols"},{"location":"documentation/ref_peridigm/#methods_3","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromstlstl_file_path-num_partitions","text":"Initialize the discretization from an STL file. stl_file_path (string): The path to the STL file. num_partitions (int): The number of partitions to split the domain into.","title":"InitFromSTL(stl_file_path, num_partitions)"},{"location":"documentation/ref_peridigm/#initfromstlstl_model-num_partitions_1","text":"Initialize the discretization from an STL model. stl_model (STLModel): The STL model to use. num_partitions (int): The number of partitions to split the domain into.","title":"InitFromSTL(stl_model, num_partitions)"},{"location":"documentation/ref_peridigm/#initfromdistancemapdistance_map_file_path-num_partitions","text":"Initialize the discretization from a distance map file. distance_map_file_path (string): The path to the distance map file. num_partitions (int): The number of partitions to split the domain into.","title":"InitFromDistanceMap(distance_map_file_path, num_partitions)"},{"location":"documentation/ref_peridigm/#initfromgridgrid_file_path-num_partitions","text":"Initialize the discretization from a grid file. grid_file_path (string): The path to the grid file. num_partitions (int): The number of partitions to split the domain into.","title":"InitFromGrid(grid_file_path, num_partitions)"},{"location":"documentation/ref_peridigm/#makeporosityporosity","text":"Add porosity to the discretization. porosity (float): The porosity to add.","title":"MakePorosity(porosity)"},{"location":"documentation/ref_peridigm/#writeinputfilenode_file_path","text":"Write the input file of the discretization. node_file_path (string): The path to write the node file.","title":"WriteInputFile(node_file_path)"},{"location":"documentation/ref_peridigm/#getnodesize","text":"Get the size of the nodes in the discretization.","title":"GetNodeSize()"},{"location":"documentation/ref_peridigm/#peridigmdiscretization_2","text":"This class represents a PeriDigm discretization.","title":"PeriDigmDiscretization"},{"location":"documentation/ref_peridigm/#constructor_4","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmdiscretization_3","text":"Creates a new instance of the PeriDigmDiscretization class.","title":"PeriDigmDiscretization()"},{"location":"documentation/ref_peridigm/#enum","text":"","title":"Enum"},{"location":"documentation/ref_peridigm/#type_1","text":"An enum class for different types of PeriDigm discretization. The available values are: level_set tetmesh","title":"Type"},{"location":"documentation/ref_peridigm/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#type_2","text":"A Type value representing the type of PeriDigm discretization.","title":"type"},{"location":"documentation/ref_peridigm/#domain_splittor_1","text":"The domain splitter for the PeriDigm discretization.","title":"domain_splittor"},{"location":"documentation/ref_peridigm/#nodes_1","text":"A vector of Node objects representing the nodes of the PeriDigm discretization.","title":"nodes"},{"location":"documentation/ref_peridigm/#node_block_indices_1","text":"A vector of int values representing the block indices of the nodes.","title":"node_block_indices"},{"location":"documentation/ref_peridigm/#node_vols_1","text":"A vector of double values representing the volumes of the nodes.","title":"node_vols"},{"location":"documentation/ref_peridigm/#methods_4","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromstlfilename-numblocks","text":"Initialize the PeriDigm discretization from an STL file. filename (string): The filename of the STL file to load. numBlocks (int): The number of blocks to create.","title":"InitFromSTL(filename, numBlocks)"},{"location":"documentation/ref_peridigm/#initfromstlstl_model-numblocks","text":"Initialize the PeriDigm discretization from an STL model. stl_model (STLModel): The STL model to use for initialization. numBlocks (int): The number of blocks to create.","title":"InitFromSTL(stl_model, numBlocks)"},{"location":"documentation/ref_peridigm/#initfromdistancemapdistancemap-numblocks","text":"Initialize the PeriDigm discretization from a distance map. distanceMap (DistanceMap): The distance map to use for initialization. numBlocks (int): The number of blocks to create.","title":"InitFromDistanceMap(distanceMap, numBlocks)"},{"location":"documentation/ref_peridigm/#initfromgridgrid-numblocks","text":"Initialize the PeriDigm discretization from a grid. grid (Grid): The grid to use for initialization. numBlocks (int): The number of blocks to create.","title":"InitFromGrid(grid, numBlocks)"},{"location":"documentation/ref_peridigm/#makeporosityporosity_1","text":"Set the porosity of the PeriDigm discretization. porosity (double): The porosity to set.","title":"MakePorosity(porosity)"},{"location":"documentation/ref_peridigm/#writeinputfilefilename","text":"Write the PeriDigm discretization to a file. filename (string): The filename to write to.","title":"WriteInputFile(filename)"},{"location":"documentation/ref_peridigm/#getnodesize_1","text":"Return the size of the nodes in the PeriDigm discretization.","title":"GetNodeSize()"},{"location":"documentation/ref_peridigm/#peridigmmaterial","text":"This class represents a material model in PeriDigm.","title":"PeriDigmMaterial"},{"location":"documentation/ref_peridigm/#constructor_5","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmmaterial_1","text":"Creates a new instance of the PeriDigmMaterial class.","title":"PeriDigmMaterial()"},{"location":"documentation/ref_peridigm/#attributes_2","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#type_3","text":"An enum value that represents the type of material. The possible values are: Elastic","title":"type"},{"location":"documentation/ref_peridigm/#density","text":"The density of the material.","title":"density"},{"location":"documentation/ref_peridigm/#youngs_modulus","text":"The Young's modulus of the material.","title":"youngs_modulus"},{"location":"documentation/ref_peridigm/#poissons_ratio","text":"The Poisson's ratio of the material.","title":"poissons_ratio"},{"location":"documentation/ref_peridigm/#methods_5","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#writeinputfilefilename_1","text":"Writes the material properties to an input file. filename (string): The name of the file to write to.","title":"WriteInputFile(filename)"},{"location":"documentation/ref_peridigm/#peridigmdamagemodel","text":"This class represents a damage model in the PeriDigm library.","title":"PeriDigmDamageModel"},{"location":"documentation/ref_peridigm/#constructor_6","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmdamagemodel_1","text":"Creates a new instance of the PeriDigmDamageModel class.","title":"PeriDigmDamageModel()"},{"location":"documentation/ref_peridigm/#attributes_3","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#type_4","text":"A string representing the type of the damage model.","title":"type"},{"location":"documentation/ref_peridigm/#critical_stretch","text":"A double representing the critical stretch for the damage model.","title":"critical_stretch"},{"location":"documentation/ref_peridigm/#methods_6","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#initfromenergyreleaserateenergy_release_rate","text":"Initializes the damage model based on the energy release rate. energy_release_rate (double): The energy release rate.","title":"InitFromEnergyReleaseRate(energy_release_rate)"},{"location":"documentation/ref_peridigm/#getstretchfromenergyreleaserateenergy_release_rate","text":"Returns the stretch based on the energy release rate. energy_release_rate (double): The energy release rate.","title":"GetStretchFromEnergyReleaseRate(energy_release_rate)"},{"location":"documentation/ref_peridigm/#writeinputfilefile_name","text":"Writes the input file for the damage model. file_name (string): The name of the input file to write.","title":"WriteInputFile(file_name)"},{"location":"documentation/ref_peridigm/#peridigmblock","text":"This class represents a block in a PeriDigm simulation.","title":"PeriDigmBlock"},{"location":"documentation/ref_peridigm/#constructor_7","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmblock_1","text":"Creates a new instance of the PeriDigmBlock class.","title":"PeriDigmBlock()"},{"location":"documentation/ref_peridigm/#attributes_4","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#node_indices","text":"A list of the node indices that make up the block.","title":"node_indices"},{"location":"documentation/ref_peridigm/#material_id","text":"An integer ID for the material that the block is composed of.","title":"material_id"},{"location":"documentation/ref_peridigm/#damage_model_id","text":"An integer ID for the damage model used to simulate damage in the block.","title":"damage_model_id"},{"location":"documentation/ref_peridigm/#horizon","text":"The horizon used in the simulation.","title":"horizon"},{"location":"documentation/ref_peridigm/#methods_7","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#writeinputfilefile_name_1","text":"Writes the block information to an input file. file_name (string): The name of the file to write to.","title":"WriteInputFile(file_name)"},{"location":"documentation/ref_peridigm/#peridigmboundarycondition","text":"This class represents a boundary condition in the PeriDigm code.","title":"PeriDigmBoundaryCondition"},{"location":"documentation/ref_peridigm/#constructor_8","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmboundarycondition_1","text":"Creates a new instance of the PeriDigmBoundaryCondition class.","title":"PeriDigmBoundaryCondition()"},{"location":"documentation/ref_peridigm/#attributes_5","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#type_5","text":"An enum that specifies the type of boundary condition. The possible values are:","title":"type"},{"location":"documentation/ref_peridigm/#prescribed_displacement","text":"The boundary condition is specified by a prescribed displacement.","title":"Prescribed_Displacement"},{"location":"documentation/ref_peridigm/#body_force","text":"The boundary condition is specified by a body force.","title":"Body_Force"},{"location":"documentation/ref_peridigm/#node_indices_1","text":"A list of integers that specify the indices of the nodes that the boundary condition applies to.","title":"node_indices"},{"location":"documentation/ref_peridigm/#dim_activated","text":"A list of integers that specify the dimensions that the boundary condition is activated in. The possible values are 0, 1, and 2, which correspond to the x, y, and z directions, respectively.","title":"dim_activated"},{"location":"documentation/ref_peridigm/#disp_rate","text":"A float that specifies the rate of displacement for the boundary condition.","title":"disp_rate"},{"location":"documentation/ref_peridigm/#loading_rate","text":"A float that specifies the rate of loading for the boundary condition.","title":"loading_rate"},{"location":"documentation/ref_peridigm/#disp","text":"A float that specifies the displacement for the boundary condition.","title":"disp"},{"location":"documentation/ref_peridigm/#loading","text":"A float that specifies the loading for the boundary condition.","title":"loading"},{"location":"documentation/ref_peridigm/#mech_time","text":"A float that specifies the mechanical time for the boundary condition.","title":"mech_time"},{"location":"documentation/ref_peridigm/#methods_8","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#insertnodenode_index","text":"Insert a node into the list of nodes that the boundary condition applies to. node_index (int): The index of the node to insert.","title":"InsertNode(node_index)"},{"location":"documentation/ref_peridigm/#setactivateddimensionsdimensions","text":"Set the dimensions that the boundary condition is activated in. dimensions (list of int): A list of integers that specify the dimensions that the boundary condition is activated in.","title":"SetActivatedDimensions(dimensions)"},{"location":"documentation/ref_peridigm/#setbydisplacementraterate","text":"Set the boundary condition by a prescribed displacement rate. rate (float): The rate of displacement to use.","title":"SetByDisplacementRate(rate)"},{"location":"documentation/ref_peridigm/#setbyloadingraterate","text":"Set the boundary condition by a prescribed loading rate. rate (float): The rate of loading to use.","title":"SetByLoadingRate(rate)"},{"location":"documentation/ref_peridigm/#setbyultimatedisplacementdisplacement","text":"Set the boundary condition by a prescribed ultimate displacement. displacement (float): The ultimate displacement to use.","title":"SetByUltimateDisplacement(displacement)"},{"location":"documentation/ref_peridigm/#setbyultimateloadingloading","text":"Set the boundary condition by a prescribed ultimate loading. loading (float): The ultimate loading to use.","title":"SetByUltimateLoading(loading)"},{"location":"documentation/ref_peridigm/#writeinputfilefilename_2","text":"Write the boundary condition to an input file. filename (string): The name of the file to write to.","title":"WriteInputFile(filename)"},{"location":"documentation/ref_peridigm/#peridigmsettings","text":"This class represents the settings for the PeriDigm code.","title":"PeriDigmSettings"},{"location":"documentation/ref_peridigm/#constructor_9","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmsettings_1","text":"Creates a new instance of the PeriDigmSettings class.","title":"PeriDigmSettings()"},{"location":"documentation/ref_peridigm/#attributes_6","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#result_dir","text":"A string representing the directory where the simulation results are stored.","title":"result_dir"},{"location":"documentation/ref_peridigm/#peridigm_exe","text":"A string representing the path to the PeriDigm executable.","title":"peridigm_exe"},{"location":"documentation/ref_peridigm/#horizon_factor","text":"A float representing the factor used to determine the horizon for each particle.","title":"horizon_factor"},{"location":"documentation/ref_peridigm/#use_auto_timestep","text":"A boolean indicating whether to use an automatic time step or not.","title":"use_auto_timestep"},{"location":"documentation/ref_peridigm/#timestep","text":"A float representing the time step size to be used.","title":"timestep"},{"location":"documentation/ref_peridigm/#timestep_factor","text":"A float representing the factor used to determine the time step size for each particle.","title":"timestep_factor"},{"location":"documentation/ref_peridigm/#mech_time_1","text":"A float representing the total mechanical time of the simulation.","title":"mech_time"},{"location":"documentation/ref_peridigm/#loading_radius_factor","text":"A float representing the factor used to determine the loading radius for each particle.","title":"loading_radius_factor"},{"location":"documentation/ref_peridigm/#constrain_radius_factor","text":"A float representing the factor used to determine the constrain radius for each particle.","title":"constrain_radius_factor"},{"location":"documentation/ref_peridigm/#output_freqency","text":"An integer representing the frequency of output data.","title":"output_freqency"},{"location":"documentation/ref_peridigm/#methods_9","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#writeinputfileinput_file_path","text":"Writes the input file for the PeriDigm code. input_file_path (string): The path to the input file to write.","title":"WriteInputFile(input_file_path)"},{"location":"documentation/ref_peridigm/#demfragment","text":"This class represents a discrete element method (DEM) fragment.","title":"DEMFragment"},{"location":"documentation/ref_peridigm/#constructor_10","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#demfragment_1","text":"Creates a new instance of the DEMFragment class.","title":"DEMFragment()"},{"location":"documentation/ref_peridigm/#attributes_7","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#shape_type","text":"An integer that represents the shape type of the fragment.","title":"shape_type"},{"location":"documentation/ref_peridigm/#sphere_size","text":"A float that represents the sphere size of the fragment.","title":"sphere_size"},{"location":"documentation/ref_peridigm/#stl_model","text":"A STLModel object that represents the STL model of the fragment.","title":"stl_model"},{"location":"documentation/ref_peridigm/#vel","text":"A Vec3d object that represents the velocity of the fragment.","title":"vel"},{"location":"documentation/ref_peridigm/#spin","text":"A Vec3d object that represents the spin of the fragment.","title":"spin"},{"location":"documentation/ref_peridigm/#methods_10","text":"InitLevelSet(level_set) Applies a boundary force to the fragment based on the given level set. level_set (LevelSet): A level set that represents the boundary.","title":"Methods"},{"location":"documentation/ref_peridigm/#resolveroverlapother_frag","text":"Resolves the overlap between this fragment and another fragment. other_frag (DEMFragment): The other fragment to resolve the overlap with.","title":"ResolverOverlap(other_frag)"},{"location":"documentation/ref_peridigm/#reinitstlmodel","text":"Re-initializes the STL model of the fragment.","title":"ReInitSTLModel()"},{"location":"documentation/ref_peridigm/#particlestrengthparameters","text":"This class represents the strength parameters of a particle.","title":"ParticleStrengthParameters"},{"location":"documentation/ref_peridigm/#constructor_11","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#particlestrengthparameters_1","text":"Creates a new instance of the ParticleStrengthParameters class.","title":"ParticleStrengthParameters()"},{"location":"documentation/ref_peridigm/#attributes_8","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#ref_size","text":"The reference size of the particle.","title":"ref_size"},{"location":"documentation/ref_peridigm/#ref_energy_release_rate","text":"The reference energy release rate of the particle.","title":"ref_energy_release_rate"},{"location":"documentation/ref_peridigm/#weibull_modulus","text":"The Weibull modulus of the particle.","title":"weibull_modulus"},{"location":"documentation/ref_peridigm/#weibull_coef_a","text":"The Weibull coefficient A of the particle.","title":"weibull_coef_a"},{"location":"documentation/ref_peridigm/#weibull_coef_b","text":"The Weibull coefficient B of the particle.","title":"weibull_coef_b"},{"location":"documentation/ref_peridigm/#min_breakable_size","text":"The minimum breakable size of the particle.","title":"min_breakable_size"},{"location":"documentation/ref_peridigm/#methods_11","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#getenergyreleaseratesize","text":"Calculates the energy release rate of the particle for a given size. size (float): The size of the particle.","title":"GetEnergyReleaseRate(size)"},{"location":"documentation/ref_peridigm/#getenergyreleaseratesize-strength","text":"Calculates the energy release rate of the particle for a given size and strength. size (float): The size of the particle. strength (float): The strength of the particle.","title":"GetEnergyReleaseRate(size, strength)"},{"location":"documentation/ref_peridigm/#peridigmsimulator","text":"This class represents a PeriDigm simulator.","title":"PeriDigmSimulator"},{"location":"documentation/ref_peridigm/#constructor_12","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmsimulator_1","text":"Creates a new instance of the PeriDigmSimulator class.","title":"PeriDigmSimulator()"},{"location":"documentation/ref_peridigm/#attributes_9","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#discretization","text":"The discretization used in the simulation.","title":"discretization"},{"location":"documentation/ref_peridigm/#materials","text":"The materials used in the simulation.","title":"materials"},{"location":"documentation/ref_peridigm/#damage_models","text":"The damage models used in the simulation.","title":"damage_models"},{"location":"documentation/ref_peridigm/#blocks","text":"The blocks used in the simulation.","title":"blocks"},{"location":"documentation/ref_peridigm/#boundary_conditions","text":"The boundary conditions used in the simulation.","title":"boundary_conditions"},{"location":"documentation/ref_peridigm/#settings","text":"The settings used in the simulation.","title":"settings"},{"location":"documentation/ref_peridigm/#methods_12","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#clear","text":"Clears all data associated with the simulator.","title":"Clear()"},{"location":"documentation/ref_peridigm/#insertmaterialmaterial","text":"Inserts a material into the simulator. material (Material): The material to insert.","title":"InsertMaterial(material)"},{"location":"documentation/ref_peridigm/#insertdamagemodeldamage_model","text":"Inserts a damage model into the simulator. damage_model (DamageModel): The damage model to insert.","title":"InsertDamageModel(damage_model)"},{"location":"documentation/ref_peridigm/#insertblockblock","text":"Inserts a block into the simulator. block (Block): The block to insert.","title":"InsertBlock(block)"},{"location":"documentation/ref_peridigm/#insertboundaryconditionboundary_condition","text":"Inserts a boundary condition into the simulator. boundary_condition (BoundaryCondition): The boundary condition to insert.","title":"InsertBoundaryCondition(boundary_condition)"},{"location":"documentation/ref_peridigm/#initdefaultsetup","text":"Initializes the simulator with default settings.","title":"InitDefaultSetup()"},{"location":"documentation/ref_peridigm/#initautotimestep","text":"Initializes the simulator with automatic timestep settings.","title":"InitAutoTimestep()"},{"location":"documentation/ref_peridigm/#writenodefile","text":"Writes the node file for the simulator.","title":"WriteNodeFile()"},{"location":"documentation/ref_peridigm/#writenodesetfile","text":"Writes the node set file for the simulator.","title":"WriteNodeSetFile()"},{"location":"documentation/ref_peridigm/#writeinputfile","text":"Writes the input file for the simulator.","title":"WriteInputFile()"},{"location":"documentation/ref_peridigm/#solve","text":"Runs the simulation.","title":"Solve()"},{"location":"documentation/ref_peridigm/#setupresultdirectory","text":"Sets up the result directory for the simulation.","title":"SetUpResultDirectory()"},{"location":"documentation/ref_peridigm/#cleanupresultdirectory","text":"Cleans up the result directory for the simulation.","title":"CleanUpResultDirectory()"},{"location":"documentation/ref_peridigm/#peridigmdemcoupler","text":"This class represents a coupler between the Peridynamics and DEM models.","title":"PeriDigmDEMCoupler"},{"location":"documentation/ref_peridigm/#constructor_13","text":"","title":"Constructor"},{"location":"documentation/ref_peridigm/#peridigmdemcoupler_1","text":"Creates a new instance of the PeriDigmDEMCoupler class.","title":"PeriDigmDEMCoupler()"},{"location":"documentation/ref_peridigm/#attributes_10","text":"","title":"Attributes"},{"location":"documentation/ref_peridigm/#particle","text":"The Peridynamics particle system.","title":"particle"},{"location":"documentation/ref_peridigm/#pd_sim","text":"The Peridynamics simulation.","title":"pd_sim"},{"location":"documentation/ref_peridigm/#base_dir","text":"The base directory for output files.","title":"base_dir"},{"location":"documentation/ref_peridigm/#sub_dir_index","text":"The sub-directory index for output files.","title":"sub_dir_index"},{"location":"documentation/ref_peridigm/#mesh_res","text":"The resolution of the DEM mesh.","title":"mesh_res"},{"location":"documentation/ref_peridigm/#node_size_ave","text":"The average size of the DEM mesh nodes.","title":"node_size_ave"},{"location":"documentation/ref_peridigm/#mech_time_2","text":"The mechanical time step size.","title":"mech_time"},{"location":"documentation/ref_peridigm/#surface_stl","text":"The path to the STL file representing the surface of the simulation domain.","title":"surface_stl"},{"location":"documentation/ref_peridigm/#boundary_force_nodes","text":"The nodes on the boundary where forces are applied.","title":"boundary_force_nodes"},{"location":"documentation/ref_peridigm/#boundary_force_node_vols","text":"The volumes associated with the boundary force nodes.","title":"boundary_force_node_vols"},{"location":"documentation/ref_peridigm/#boundary_force_values","text":"The values of the boundary forces.","title":"boundary_force_values"},{"location":"documentation/ref_peridigm/#unbalanced_force_nodes","text":"The nodes where unbalanced forces are applied.","title":"unbalanced_force_nodes"},{"location":"documentation/ref_peridigm/#unbalanced_force_values","text":"The values of the unbalanced forces.","title":"unbalanced_force_values"},{"location":"documentation/ref_peridigm/#use_customized_loading_rate","text":"A flag indicating whether to use a customized loading rate.","title":"use_customized_loading_rate"},{"location":"documentation/ref_peridigm/#loading_rate_1","text":"The loading rate.","title":"loading_rate"},{"location":"documentation/ref_peridigm/#loading_steps","text":"The number of loading steps.","title":"loading_steps"},{"location":"documentation/ref_peridigm/#is_broken","text":"A flag indicating whether the material is broken.","title":"is_broken"},{"location":"documentation/ref_peridigm/#damage_fraction_limit","text":"The damage fraction limit.","title":"damage_fraction_limit"},{"location":"documentation/ref_peridigm/#fragment_vol_limit","text":"The fragment volume limit.","title":"fragment_vol_limit"},{"location":"documentation/ref_peridigm/#ignore_fines","text":"A flag indicating whether to ignore fines.","title":"ignore_fines"},{"location":"documentation/ref_peridigm/#use_alpha_shape","text":"A flag indicating whether to use alpha shape.","title":"use_alpha_shape"},{"location":"documentation/ref_peridigm/#fragment_alpha","text":"The alpha value for fragmenting.","title":"fragment_alpha"},{"location":"documentation/ref_peridigm/#strength_params","text":"The strength parameters.","title":"strength_params"},{"location":"documentation/ref_peridigm/#material_params","text":"The material parameters.","title":"material_params"},{"location":"documentation/ref_peridigm/#methods_13","text":"","title":"Methods"},{"location":"documentation/ref_peridigm/#init","text":"Initializes the DEM coupler.","title":"Init()"},{"location":"documentation/ref_peridigm/#applyboundaryforce","text":"Applies the boundary forces.","title":"ApplyBoundaryForce()"},{"location":"documentation/ref_peridigm/#solve_1","text":"Solves the DEM coupler.","title":"Solve()"},{"location":"documentation/ref_peridigm/#checkbreakage","text":"Checks for breakage.","title":"CheckBreakage()"},{"location":"documentation/ref_peridigm/#getfragments","text":"Gets the fragments. User manual \u250a Previous \u250a Next","title":"GetFragments()"},{"location":"documentation/ref_scene/","text":"User manual \u250a Previous \u250a Next DEMObjectPool This class represents a pool of DEM objects. Constructor The DEMObjectPool class does not have a constructor. Methods init() Initialize the DEMObjectPool. GetParticle() Get a reference to a particle object in the pool. Returns: A reference to a Particle object. GetContactPP() Get a reference to a ContactPP object in the pool. Returns: A reference to a ContactPP object. GetContactPW() Get a reference to a ContactPW object in the pool. Returns: A reference to a ContactPW object. Clone(contact_pp) Create a copy of a ContactPP object in the pool. contact_pp (ContactPP const*): A pointer to the ContactPP object to clone. Returns: A reference to a new ContactPP object. Clone(contact_pw) Create a copy of a ContactPW object in the pool. contact_pw (ContactPW const*): A pointer to the ContactPW object to clone. Returns:A reference to a new ContactPW object. Scene This class represents a simulation scene. Constructor Scene() Creates a new instance of the Scene class. Attributes gravity_coef A float representing the gravitational acceleration coefficient. contact_model_map A dictionary mapping contact model labels to their corresponding ContactModel objects. bond_model_table A list of bond model names. collision_model_table A list of collision model names. particle_list A list of Particle objects. particle_proxy_list A list of ParticleProxy objects. particle_ghost_list A list of ParticleGhost objects. wall_list A list of Wall objects. wall_ghost_list A list of WallGhost objects. particle_map A dictionary mapping particle IDs to their corresponding Particle objects. shape_map A dictionary mapping shape IDs to their corresponding Shape objects. local_shape_list A list of local shape IDs. Methods InsertContactModel(contact_model) Inserts a contact model into the scene. contact_model (ContactModel): The contact model to insert. SetNumberOfMaterials(num_materials) Sets the number of materials in the scene. num_materials (int): The number of materials. SetCollisionModel(i, j, contact_model) Sets the collision model between two materials. i (int): The index of the first material. j (int): The index of the second material. contact_model (ContactModel): The contact model to use for the collision. InsertShape(shape) Inserts a shape into the scene. shape (Shape): The shape to insert. InsertShape(shapes) Inserts multiple shapes into the scene. shapes (list of Shape): The shapes to insert. InsertParticle(particle) Inserts a particle into the scene. particle (Particle): The particle to insert. InsertParticle(particles) Inserts multiple particles into the scene. particles (list of Particle): The particles to insert. InsertParticle(bonded_spheres) Inserts a bonded sphere into the scene. bonded_spheres (BondedSpheres): The bonded sphere to insert. InsertParticle(bonded_spheres_list) Inserts multiple bonded spheres into the scene. bonded_spheres_list (list of BondedSpheres): The bonded spheres to insert. InsertParticle(bonded_voronois) Inserts a bonded Voronoi into the scene. bonded_voronois (BondedVoronois): The bonded Voronoi to insert. InsertParticle(bonded_voronois_list) Inserts multiple bonded Voronois into the scene. bonded_voronois_list (list of BondedVoronois): The bonded Voronois to insert. InsertWall(wall) Inserts a wall into the scene. wall (Wall): The wall to insert. InsertWall(walls) Inserts multiple walls into the scene. walls (list of Wall): The walls to insert. RemoveShape(shape) Removes a shape from the scene. shape (Shape): The shape to remove. RemoveParticle(particle) Removes a particle from the scene. particle (Particle): The particle to remove. RemoveParticle(index) Removes a particle from the scene by its index. index (int): The index of the particle to remove. RemoveWall(wall) Removes a wall from the scene. wall (Wall): The wall to remove. RemoveWall(index) Removes a wall from the scene by its index. index (int): The index of the wall to remove. InsertContactModel(contact_model) Inserts a contact model into the scene. contact_model (ContactModel): The contact model to insert. GetShapes() Returns a reference to the vector of shapes in the scene. InScene(shape) Checks if a shape is in the scene. shape (Shape): The shape to check. InScene(contact_model) Checks if a contact model is in the scene. contact_model (ContactModel): The contact model to check. SetNumberOfMaterials(num_materials) Sets the number of materials in the scene. num_materials (int): The number of materials. SetBondModel(i, j, contact_model) Sets the bond model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model (ContactModel): The contact model to use for the bond. SetBondModel(i, j, contact_model_label) Sets the bond model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model_label (str): The label of the contact model to use for the bond. SetCollisionModel(i, j, contact_model) Sets the collision model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model (ContactModel): The contact model to use for the collision. SetCollisionModel(i, j, contact_model_label) Sets the collision model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model_label (str): The label of the contact model to use for the collision. SetGravity(gravity) Sets the gravity vector for the scene. gravity (Vec3): The gravity vector. GetBondModel(particle1, particle2) Gets the bond model between two particles. particle1 (Particle): The first particle. particle2 (Particle): The second particle. GetBondModel(particle, wall) Gets the bond model between a particle and a wall. particle (Particle): The particle. wall (Wall): The wall. GetCollisionModel(particle1, particle2) Returns a reference to the collision model between two particles. particle1 (Particle): The first particle. particle2 (Particle): The second particle. GetCollisionModel(particle, wall) Returns a reference to the collision model between a particle and a wall. particle (Particle): The particle. wall (Wall): The wall. AutoReadRestart() Automatically reads restart files and sets up the simulation accordingly. ReadRestartShapes() Reads the shape data from a restart file. ReadRestartParticles() Reads the particle data from a restart file. ReadRestartWalls() Reads the wall data from a restart file. ReadRestartContacts() Reads the contact data from a restart file. GetContactPPs() Returns a list of all particle-particle contacts in the simulation. GetContactPWs() Returns a list of all particle-wall contacts in the simulation. ClearShapes() Removes all shapes from the scene. ClearParticles() Removes all particles from the scene. ClearWalls() Removes all walls from the scene. ClearContactModels() Removes all contact models from the scene. ClearContacts() Removes all contacts from the scene. FindParticle(particle_id) Finds a particle in the simulation by its ID. particle_id (int): The ID of the particle. FindWall(wall_id) Finds a wall in the simulation by its ID. wall_id (int): The ID of the wall. PackGenerator This class represents a pack generator. Constructor PackGenerator() Creates a new instance of the PackGenerator class. Static Methods GetGridPack() Generates a pack using a grid-based algorithm. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, shapes): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided shapes. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, shape_vec): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided vector of shapes. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, bonded_spheres): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided bonded spheres. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, bonded_voronois): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided bonded Voronois. GetVoronoiPack Generates a pack using a Voronoi-based algorithm. GetVoronoiPack(xmin, xmax, ymin, ymax, zmin, zmax, n, shapes): Generates a pack using a Voronoi-based algorithm with the given dimensions and number of cells in each direction, using the provided shapes. GetVoronoiPack(xmin, xmax, ymin, ymax, zmin, zmax, n, shape_vec): Generates a pack using a Voronoi-based algorithm with the given dimensions and number of cells in each direction, using the provided vector of shapes. GetVoronoiPack(stl_model, n, shape): Generates a pack using a Voronoi-based algorithm with the given STL model and number of cells in each direction, using the provided shape. GetVoronoiPack(stl_model, n, shape_vec): Generates a pack using a Voronoi-based algorithm with the given STL model and number of cells in each direction, using the provided vector of shapes. Particle This class represents a particle in a simulation. Constructor Particle() Creates a new instance of the Particle class. Attributes id The ID of the particle. shape A reference to the shape of the particle. bound_min The minimum bound of the particle. bound_max The maximum bound of the particle. margin The margin of the particle. bound_disp The displacement of the particle. material_type The type of material of the particle. density The density of the particle. mass The mass of the particle. moi_principal The moment of inertia of the particle. damp_global The global damping of the particle. pos The position of the particle. quaternion The quaternion of the particle. vel The velocity of the particle. spin The spin of the particle. vel_m0p5 The velocity of the particle divided by 0.5. spin_principal The principal spin of the particle. force The force acting on the particle. moment The moment acting on the particle. dynamic_properties The dynamic properties of the particle. enable_rotation Whether the particle is allowed to rotate. enable_bound_aabb Whether the particle is bound by an AABB. need_update_linked_list Whether the particle's linked list needs to be updated. linked_cell_list The linked cell list of the particle. linked_particle_list The linked particle list of the particle. linked_wall_list The linked wall list of the particle. contact_pp_lookup_table The lookup table for particle-particle contact. contact_pw_lookup_table The lookup table for particle-wall contact. is_on_edge Whether the particle is on an edge. need_send_out Whether the particle needs to be sent out. linked_domain_list The linked domain list of the particle. need_update_stl_model Whether the particle's STL model needs to be updated. stl_model The STL model of the particle. Wall This class represents a wall object. Constructor Wall() Creates a new instance of the Wall class. Wall(shape) Creates a new instance of the Wall class with a specified shape. shape (Shape): The shape of the wall. Attributes id An integer ID for the wall. label A string label for the wall. shape The shape of the wall. material_type The material type of the wall. enable_rotation A boolean indicating whether the wall is allowed to rotate. enable_bound_aabb A boolean indicating whether the wall has an axis-aligned bounding box. bound_min The minimum position of the bounding box. bound_max The maximum position of the bounding box. bound_disp The displacement of the bounding box. pos The position of the wall. quaternion The quaternion orientation of the wall. force The force acting on the wall. moment The moment acting on the wall. vel The velocity of the wall. spin The spin of the wall. vel_spin The velocity spin of the wall. dynamic_properties A map containing the dynamic properties of the wall. need_update_linked_list A boolean indicating whether the wall's linked list needs to be updated. linked_cell_list A list of linked cells. linked_particle_list A list of linked particles. contact_pw_lookup_table A lookup table for pairwise contacts. need_update_stl_model A boolean indicating whether the wall's STL model needs to be updated. stl_model The STL model of the wall. Methods SetShape(shape) Sets the shape of the wall. shape (Shape): The shape of the wall. SetPosition(pos) Sets the position of the wall. pos (Vec3d): The position of the wall. SetRodrigues(rot) Sets the Rodrigues rotation of the wall. rot (Vec3d): The Rodrigues rotation of the wall. SetQuaternion(quat) Sets the quaternion orientation of the wall. quat (Vec4d): The quaternion orientation of the wall. SetVelocity(vel) Sets the velocity of the wall. vel (Vec3d): The velocity of the wall. SetSpin(spin) Sets the spin of the wall. spin (Vec3d): The spin of the wall. SetVelocitySpin(vel, spin) Sets the velocity and spin of the wall. vel (Vec3d): The velocity of the wall. spin (Vec3d): The spin of the wall. GetVelocity() Return: the velocity of the wall. SetDynamicProperty(prop_name, prop_value) Sets a dynamic property of the wall. prop_name (string): The name of the dynamic property to set. prop_value (float): The value to set for the dynamic property. GetDynamicProperty(prop_name) Returns the value of a dynamic property of the wall. prop_name (string): The name of the dynamic property. AddForce(force) Adds a force to the wall. force (Vec3d): The force to add. AddMoment(moment) Adds a moment to the wall. moment (Vec3d): The moment to add. AddForce(f) Add a force to the wall. f (Vec3d): The force to add. AddMoment(m) Add a moment to the wall. m (Vec3d): The moment to add. AddForceAtomic(f) Add an atomic force to the wall. f (Vec3d): The atomic force to add. AddMomentAtomic(m) Add an atomic moment to the wall. m (Vec3d): The atomic moment to add. ClearForce() Clear the total force on the wall. ClearMoment() Clear the total moment on the wall. ApplyContactForce(contact_pw, contact_force) Apply a contact force to the wall. contact_pw : The contact point on the wall. contact_force : The contact force to apply. UpdateContactForce(contact_pw, contact_force) Update the contact force on the wall. contact_pw (Vec3d): The contact point on the wall. contact_force (Vec3d): The new contact force. UpdateMotion() Update the motion of the wall. t (double, optional): The time step. Default is 0. UpdateMotion(pos, quat, t) Update the motion of the wall. pos (Vec3d): The position of the wall. quat (Vec4d): The quaternion of the wall. t (double, optional): The time step. Default is 0. UpdateMotion(pos, euler, t) Update the motion of the wall. pos (Vec3d): The position of the wall. euler (Vec3d): The Euler angles of the wall. t (double, optional): The time step. Default is 0. UpdateBound() Update the bounding box of the wall. ClearLinkedCells() Clear the linked cells of the wall. ClearLinkedNeighs() Clear the linked neighbors of the wall. BuildContactLookUpTable() Build the contact lookup table of the wall. ClearContactLookUpTable() Clear the contact lookup table of the wall. UpdateLinkedCells() Update the linked cells of the wall. UpdateLinkedNeighs() Update the linked neighbors of the wall. GetContactPWs() Get the contact points and weights of the wall. UpdateSTLModel() Update the STL model of the wall. SaveAsVTK(file_name) Save the wall as a VTK file. file_name (string): The name of the file to save. Print() Print the wall. FindLinked() Find the linked objects of the wall. FindContactRef(contact_pw) Find the contact reference object of the wall. WallBoxPlane Constructor WallBoxPlane(x, y, z, w, h, d) Creates a new instance of the WallBoxPlane class with the following parameters: x (float): x coordinate of the center of the box y (float): y coordinate of the center of the box z (float): z coordinate of the center of the box w (float): width of the box h (float): height of the box d (float): depth of the box Methods GetShapes() Returns a list of shape objects of the wall. GetWalls() Returns a list of wall objects of the wall. ImportToScene() Imports the wall object to the simulation scene. WallBoxPlate These classes represent wall objects in the simulation scene, with a box shape and a plane or a plate surface. Constructor WallBoxPlate(x, y, z, w, h, d) Creates a new instance of the WallBoxPlate class with the following parameters: x (float): x coordinate of the center of the box y (float): y coordinate of the center of the box z (float): z coordinate of the center of the box w (float): width of the box h (float): height of the box d (float): depth of the box Methods GetShapes() Returns a list of shape objects of the wall. GetWalls() Returns a list of wall objects of the wall. ImportToScene() Imports the wall object to the simulation scene. BondedSpheres This function initializes a PyBind11 module for the BondedSpheres class. Attributes sphere A Sphere object representing the bonded sphere. particle_list A list of Particle objects. contact_list A list of Contact objects. bond_pair_list A list of bonded particle pairs. bond_model A reference to the BondModel object used to calculate bonds. Methods init() The default constructor. init(BondedSpheres) A copy constructor that initializes a BondedSpheres object from another BondedSpheres object. SetBondModel() Sets the bond model used to calculate bonds. Translate() Translates the BondedSpheres object. RotateByRodrigues() Rotates the BondedSpheres object using Rodrigues' rotation formula. GetCentroid() Returns the centroid of the BondedSpheres object. InitFromSTL() Initializes the BondedSpheres object from an STL file. filename (string): The path to the STL file. radius (float): The radius of the sphere. InitFromGrid() Initializes the BondedSpheres object from a grid. MakePorosity() Creates porosity in the BondedSpheres object. InitBonds() Initializes the bonded pairs in the BondedSpheres object. ImportToScene() Imports the BondedSpheres object to a scene. BondedVoronois This class represents a bonded Voronois object. Constructor BondedVoronois() Creates a new instance of the BondedVoronois class. Attributes trimesh_list A list of trimeshes. particle_list A list of particles. contact_list A list of contacts. bond_pair_list A list of bond pairs. cvt_max_iters The maximum number of iterations for the CVT algorithm. cvt_tol The tolerance for the CVT algorithm. bond_model The bond model used by the BondedVoronois object. Methods SetBondModel(bond_model) Set the bond model used by the BondedVoronois object. bond_model (BondModel): The bond model to set. Translate(x, y, z) Translate the BondedVoronois object. x (float): The amount to translate in the x direction. y (float): The amount to translate in the y direction. z (float): The amount to translate in the z direction. RotateByRodrigues(theta, u) Rotate the BondedVoronois object by the Rodrigues formula. theta (float): The angle of rotation. u (array-like): The axis of rotation. GetCentroid() Get the centroid of the BondedVoronois object. InitFromSTL(stl_file, label='') Initialize the BondedVoronois object from an STL file. stl_file (string): The path to the STL file. label (string, optional): A label for the object. Default is an empty string. MakePorosity(porosity) Make the BondedVoronois object porous. porosity (float): The desired porosity. InitBonds() Initialize the bonds of the BondedVoronois object. RefreshPointers() Refresh the pointers of the BondedVoronois object. SaveAsVTK(filename) Save the BondedVoronois object as a VTK file. filename (string): The name of the VTK file. ImportToScene(scene) Import the BondedVoronois object to a scene. scene (Scene): The scene to import to. ContactPP This class represents a contact model between two particles. Constructor ContactPP() Creates a new instance of the ContactPP class. ContactPP(particle_1, particle_2) Creates a new instance of the ContactPP class with the given particles. particle_1 (Particle* const): Pointer to the first particle. particle_2 (Particle* const): Pointer to the second particle. Attributes particle_1 Pointer to the first particle involved in the contact. particle_2 Pointer to the second particle involved in the contact. bond_entries A vector of bond entries for the contact. collision_entries A vector of collision entries for the contact. active A boolean value indicating whether the contact is active or not. dynamic_properties A dictionary of dynamic properties for the contact. Methods SetBondModel(bond_model) Set the bond model for the contact. bond_model (BondModel*): Pointer to the bond model. SetCollisionModel(collision_model) Set the collision model for the contact. collision_model (CollisionModel*): Pointer to the collision model. EvaluateForceMoment() Evaluate the force and moment for the contact. ApplyToParticle() Apply the contact force and moment to the particles. ApplyToParticle1() Apply the contact force and moment to the first particle. ApplyToParticle2() Apply the contact force and moment to the second particle. IsActive() Return a boolean indicating whether the contact is active or not. Clear() Clear the contact data. Print() Print the contact data. ContactPW This class represents a contact between a particle and a wall. Constructor ContactPW(particle, wall) Creates a new instance of the ContactPW class with a given particle and wall. particle (Particle object): The particle involved in the contact. wall (Wall object): The wall involved in the contact. Attributes particle The particle involved in the contact. wall The wall involved in the contact. bond_model The bond model used for the contact. collision_model The collision model used for the contact. bond_entries A list of bond entries for the contact. collision_entries A list of collision entries for the contact. active A boolean flag indicating whether the contact is currently active. dynamic_properties A dictionary of dynamic properties associated with the contact. Methods SetBondModel(bond_model) Set the bond model for the contact. bond_model (BondModel object): The bond model to use for the contact. SetCollisionModel(collision_model) Set the collision model for the contact. collision_model (CollisionModel object): The collision model to use for the contact. EvaluateForceMoment() Calculate and return the force and moment of the contact. ApplyToParticle() Apply the contact to the particle involved in the contact. ApplyToWall() Apply the contact to the wall involved in the contact. IsActive() Return True if the contact is currently active, False otherwise. Clear() Clear all bond and collision entries for the contact. Print() Print information about the contact. User manual \u250a Previous \u250a Next","title":"Ref scene"},{"location":"documentation/ref_scene/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_scene/#demobjectpool","text":"This class represents a pool of DEM objects.","title":"DEMObjectPool"},{"location":"documentation/ref_scene/#constructor","text":"The DEMObjectPool class does not have a constructor.","title":"Constructor"},{"location":"documentation/ref_scene/#methods","text":"","title":"Methods"},{"location":"documentation/ref_scene/#init","text":"Initialize the DEMObjectPool.","title":"init()"},{"location":"documentation/ref_scene/#getparticle","text":"Get a reference to a particle object in the pool. Returns: A reference to a Particle object.","title":"GetParticle()"},{"location":"documentation/ref_scene/#getcontactpp","text":"Get a reference to a ContactPP object in the pool. Returns: A reference to a ContactPP object.","title":"GetContactPP()"},{"location":"documentation/ref_scene/#getcontactpw","text":"Get a reference to a ContactPW object in the pool. Returns: A reference to a ContactPW object.","title":"GetContactPW()"},{"location":"documentation/ref_scene/#clonecontact_pp","text":"Create a copy of a ContactPP object in the pool. contact_pp (ContactPP const*): A pointer to the ContactPP object to clone. Returns: A reference to a new ContactPP object.","title":"Clone(contact_pp)"},{"location":"documentation/ref_scene/#clonecontact_pw","text":"Create a copy of a ContactPW object in the pool. contact_pw (ContactPW const*): A pointer to the ContactPW object to clone. Returns:A reference to a new ContactPW object.","title":"Clone(contact_pw)"},{"location":"documentation/ref_scene/#scene","text":"This class represents a simulation scene.","title":"Scene"},{"location":"documentation/ref_scene/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#scene_1","text":"Creates a new instance of the Scene class.","title":"Scene()"},{"location":"documentation/ref_scene/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#gravity_coef","text":"A float representing the gravitational acceleration coefficient.","title":"gravity_coef"},{"location":"documentation/ref_scene/#contact_model_map","text":"A dictionary mapping contact model labels to their corresponding ContactModel objects.","title":"contact_model_map"},{"location":"documentation/ref_scene/#bond_model_table","text":"A list of bond model names.","title":"bond_model_table"},{"location":"documentation/ref_scene/#collision_model_table","text":"A list of collision model names.","title":"collision_model_table"},{"location":"documentation/ref_scene/#particle_list","text":"A list of Particle objects.","title":"particle_list"},{"location":"documentation/ref_scene/#particle_proxy_list","text":"A list of ParticleProxy objects.","title":"particle_proxy_list"},{"location":"documentation/ref_scene/#particle_ghost_list","text":"A list of ParticleGhost objects.","title":"particle_ghost_list"},{"location":"documentation/ref_scene/#wall_list","text":"A list of Wall objects.","title":"wall_list"},{"location":"documentation/ref_scene/#wall_ghost_list","text":"A list of WallGhost objects.","title":"wall_ghost_list"},{"location":"documentation/ref_scene/#particle_map","text":"A dictionary mapping particle IDs to their corresponding Particle objects.","title":"particle_map"},{"location":"documentation/ref_scene/#shape_map","text":"A dictionary mapping shape IDs to their corresponding Shape objects.","title":"shape_map"},{"location":"documentation/ref_scene/#local_shape_list","text":"A list of local shape IDs.","title":"local_shape_list"},{"location":"documentation/ref_scene/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_scene/#insertcontactmodelcontact_model","text":"Inserts a contact model into the scene. contact_model (ContactModel): The contact model to insert.","title":"InsertContactModel(contact_model)"},{"location":"documentation/ref_scene/#setnumberofmaterialsnum_materials","text":"Sets the number of materials in the scene. num_materials (int): The number of materials.","title":"SetNumberOfMaterials(num_materials)"},{"location":"documentation/ref_scene/#setcollisionmodeli-j-contact_model","text":"Sets the collision model between two materials. i (int): The index of the first material. j (int): The index of the second material. contact_model (ContactModel): The contact model to use for the collision.","title":"SetCollisionModel(i, j, contact_model)"},{"location":"documentation/ref_scene/#insertshapeshape","text":"Inserts a shape into the scene. shape (Shape): The shape to insert.","title":"InsertShape(shape)"},{"location":"documentation/ref_scene/#insertshapeshapes","text":"Inserts multiple shapes into the scene. shapes (list of Shape): The shapes to insert.","title":"InsertShape(shapes)"},{"location":"documentation/ref_scene/#insertparticleparticle","text":"Inserts a particle into the scene. particle (Particle): The particle to insert.","title":"InsertParticle(particle)"},{"location":"documentation/ref_scene/#insertparticleparticles","text":"Inserts multiple particles into the scene. particles (list of Particle): The particles to insert.","title":"InsertParticle(particles)"},{"location":"documentation/ref_scene/#insertparticlebonded_spheres","text":"Inserts a bonded sphere into the scene. bonded_spheres (BondedSpheres): The bonded sphere to insert.","title":"InsertParticle(bonded_spheres)"},{"location":"documentation/ref_scene/#insertparticlebonded_spheres_list","text":"Inserts multiple bonded spheres into the scene. bonded_spheres_list (list of BondedSpheres): The bonded spheres to insert.","title":"InsertParticle(bonded_spheres_list)"},{"location":"documentation/ref_scene/#insertparticlebonded_voronois","text":"Inserts a bonded Voronoi into the scene. bonded_voronois (BondedVoronois): The bonded Voronoi to insert.","title":"InsertParticle(bonded_voronois)"},{"location":"documentation/ref_scene/#insertparticlebonded_voronois_list","text":"Inserts multiple bonded Voronois into the scene. bonded_voronois_list (list of BondedVoronois): The bonded Voronois to insert.","title":"InsertParticle(bonded_voronois_list)"},{"location":"documentation/ref_scene/#insertwallwall","text":"Inserts a wall into the scene. wall (Wall): The wall to insert.","title":"InsertWall(wall)"},{"location":"documentation/ref_scene/#insertwallwalls","text":"Inserts multiple walls into the scene. walls (list of Wall): The walls to insert.","title":"InsertWall(walls)"},{"location":"documentation/ref_scene/#removeshapeshape","text":"Removes a shape from the scene. shape (Shape): The shape to remove.","title":"RemoveShape(shape)"},{"location":"documentation/ref_scene/#removeparticleparticle","text":"Removes a particle from the scene. particle (Particle): The particle to remove.","title":"RemoveParticle(particle)"},{"location":"documentation/ref_scene/#removeparticleindex","text":"Removes a particle from the scene by its index. index (int): The index of the particle to remove.","title":"RemoveParticle(index)"},{"location":"documentation/ref_scene/#removewallwall","text":"Removes a wall from the scene. wall (Wall): The wall to remove.","title":"RemoveWall(wall)"},{"location":"documentation/ref_scene/#removewallindex","text":"Removes a wall from the scene by its index. index (int): The index of the wall to remove.","title":"RemoveWall(index)"},{"location":"documentation/ref_scene/#insertcontactmodelcontact_model_1","text":"Inserts a contact model into the scene. contact_model (ContactModel): The contact model to insert.","title":"InsertContactModel(contact_model)"},{"location":"documentation/ref_scene/#getshapes","text":"Returns a reference to the vector of shapes in the scene.","title":"GetShapes()"},{"location":"documentation/ref_scene/#insceneshape","text":"Checks if a shape is in the scene. shape (Shape): The shape to check.","title":"InScene(shape)"},{"location":"documentation/ref_scene/#inscenecontact_model","text":"Checks if a contact model is in the scene. contact_model (ContactModel): The contact model to check.","title":"InScene(contact_model)"},{"location":"documentation/ref_scene/#setnumberofmaterialsnum_materials_1","text":"Sets the number of materials in the scene. num_materials (int): The number of materials.","title":"SetNumberOfMaterials(num_materials)"},{"location":"documentation/ref_scene/#setbondmodeli-j-contact_model","text":"Sets the bond model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model (ContactModel): The contact model to use for the bond.","title":"SetBondModel(i, j, contact_model)"},{"location":"documentation/ref_scene/#setbondmodeli-j-contact_model_label","text":"Sets the bond model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model_label (str): The label of the contact model to use for the bond.","title":"SetBondModel(i, j, contact_model_label)"},{"location":"documentation/ref_scene/#setcollisionmodeli-j-contact_model_1","text":"Sets the collision model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model (ContactModel): The contact model to use for the collision.","title":"SetCollisionModel(i, j, contact_model)"},{"location":"documentation/ref_scene/#setcollisionmodeli-j-contact_model_label","text":"Sets the collision model between two particles. i (int): The index of the first particle. j (int): The index of the second particle. contact_model_label (str): The label of the contact model to use for the collision.","title":"SetCollisionModel(i, j, contact_model_label)"},{"location":"documentation/ref_scene/#setgravitygravity","text":"Sets the gravity vector for the scene. gravity (Vec3): The gravity vector.","title":"SetGravity(gravity)"},{"location":"documentation/ref_scene/#getbondmodelparticle1-particle2","text":"Gets the bond model between two particles. particle1 (Particle): The first particle. particle2 (Particle): The second particle.","title":"GetBondModel(particle1, particle2)"},{"location":"documentation/ref_scene/#getbondmodelparticle-wall","text":"Gets the bond model between a particle and a wall. particle (Particle): The particle. wall (Wall): The wall.","title":"GetBondModel(particle, wall)"},{"location":"documentation/ref_scene/#getcollisionmodelparticle1-particle2","text":"Returns a reference to the collision model between two particles. particle1 (Particle): The first particle. particle2 (Particle): The second particle.","title":"GetCollisionModel(particle1, particle2)"},{"location":"documentation/ref_scene/#getcollisionmodelparticle-wall","text":"Returns a reference to the collision model between a particle and a wall. particle (Particle): The particle. wall (Wall): The wall.","title":"GetCollisionModel(particle, wall)"},{"location":"documentation/ref_scene/#autoreadrestart","text":"Automatically reads restart files and sets up the simulation accordingly.","title":"AutoReadRestart()"},{"location":"documentation/ref_scene/#readrestartshapes","text":"Reads the shape data from a restart file.","title":"ReadRestartShapes()"},{"location":"documentation/ref_scene/#readrestartparticles","text":"Reads the particle data from a restart file.","title":"ReadRestartParticles()"},{"location":"documentation/ref_scene/#readrestartwalls","text":"Reads the wall data from a restart file.","title":"ReadRestartWalls()"},{"location":"documentation/ref_scene/#readrestartcontacts","text":"Reads the contact data from a restart file.","title":"ReadRestartContacts()"},{"location":"documentation/ref_scene/#getcontactpps","text":"Returns a list of all particle-particle contacts in the simulation.","title":"GetContactPPs()"},{"location":"documentation/ref_scene/#getcontactpws","text":"Returns a list of all particle-wall contacts in the simulation.","title":"GetContactPWs()"},{"location":"documentation/ref_scene/#clearshapes","text":"Removes all shapes from the scene.","title":"ClearShapes()"},{"location":"documentation/ref_scene/#clearparticles","text":"Removes all particles from the scene.","title":"ClearParticles()"},{"location":"documentation/ref_scene/#clearwalls","text":"Removes all walls from the scene.","title":"ClearWalls()"},{"location":"documentation/ref_scene/#clearcontactmodels","text":"Removes all contact models from the scene.","title":"ClearContactModels()"},{"location":"documentation/ref_scene/#clearcontacts","text":"Removes all contacts from the scene.","title":"ClearContacts()"},{"location":"documentation/ref_scene/#findparticleparticle_id","text":"Finds a particle in the simulation by its ID. particle_id (int): The ID of the particle.","title":"FindParticle(particle_id)"},{"location":"documentation/ref_scene/#findwallwall_id","text":"Finds a wall in the simulation by its ID. wall_id (int): The ID of the wall.","title":"FindWall(wall_id)"},{"location":"documentation/ref_scene/#packgenerator","text":"This class represents a pack generator.","title":"PackGenerator"},{"location":"documentation/ref_scene/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#packgenerator_1","text":"Creates a new instance of the PackGenerator class.","title":"PackGenerator()"},{"location":"documentation/ref_scene/#static-methods","text":"","title":"Static Methods"},{"location":"documentation/ref_scene/#getgridpack","text":"Generates a pack using a grid-based algorithm. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, shapes): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided shapes. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, shape_vec): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided vector of shapes. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, bonded_spheres): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided bonded spheres. GetGridPack(xmin, xmax, ymin, ymax, zmin, zmax, nx, ny, nz, bonded_voronois): Generates a pack using a grid-based algorithm with the given dimensions and number of cells in each direction, using the provided bonded Voronois. GetVoronoiPack Generates a pack using a Voronoi-based algorithm. GetVoronoiPack(xmin, xmax, ymin, ymax, zmin, zmax, n, shapes): Generates a pack using a Voronoi-based algorithm with the given dimensions and number of cells in each direction, using the provided shapes. GetVoronoiPack(xmin, xmax, ymin, ymax, zmin, zmax, n, shape_vec): Generates a pack using a Voronoi-based algorithm with the given dimensions and number of cells in each direction, using the provided vector of shapes. GetVoronoiPack(stl_model, n, shape): Generates a pack using a Voronoi-based algorithm with the given STL model and number of cells in each direction, using the provided shape. GetVoronoiPack(stl_model, n, shape_vec): Generates a pack using a Voronoi-based algorithm with the given STL model and number of cells in each direction, using the provided vector of shapes.","title":"GetGridPack()"},{"location":"documentation/ref_scene/#particle","text":"This class represents a particle in a simulation.","title":"Particle"},{"location":"documentation/ref_scene/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#particle_1","text":"Creates a new instance of the Particle class.","title":"Particle()"},{"location":"documentation/ref_scene/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#id","text":"The ID of the particle.","title":"id"},{"location":"documentation/ref_scene/#shape","text":"A reference to the shape of the particle.","title":"shape"},{"location":"documentation/ref_scene/#bound_min","text":"The minimum bound of the particle.","title":"bound_min"},{"location":"documentation/ref_scene/#bound_max","text":"The maximum bound of the particle.","title":"bound_max"},{"location":"documentation/ref_scene/#margin","text":"The margin of the particle.","title":"margin"},{"location":"documentation/ref_scene/#bound_disp","text":"The displacement of the particle.","title":"bound_disp"},{"location":"documentation/ref_scene/#material_type","text":"The type of material of the particle.","title":"material_type"},{"location":"documentation/ref_scene/#density","text":"The density of the particle.","title":"density"},{"location":"documentation/ref_scene/#mass","text":"The mass of the particle.","title":"mass"},{"location":"documentation/ref_scene/#moi_principal","text":"The moment of inertia of the particle.","title":"moi_principal"},{"location":"documentation/ref_scene/#damp_global","text":"The global damping of the particle.","title":"damp_global"},{"location":"documentation/ref_scene/#pos","text":"The position of the particle.","title":"pos"},{"location":"documentation/ref_scene/#quaternion","text":"The quaternion of the particle.","title":"quaternion"},{"location":"documentation/ref_scene/#vel","text":"The velocity of the particle.","title":"vel"},{"location":"documentation/ref_scene/#spin","text":"The spin of the particle.","title":"spin"},{"location":"documentation/ref_scene/#vel_m0p5","text":"The velocity of the particle divided by 0.5.","title":"vel_m0p5"},{"location":"documentation/ref_scene/#spin_principal","text":"The principal spin of the particle.","title":"spin_principal"},{"location":"documentation/ref_scene/#force","text":"The force acting on the particle.","title":"force"},{"location":"documentation/ref_scene/#moment","text":"The moment acting on the particle.","title":"moment"},{"location":"documentation/ref_scene/#dynamic_properties","text":"The dynamic properties of the particle.","title":"dynamic_properties"},{"location":"documentation/ref_scene/#enable_rotation","text":"Whether the particle is allowed to rotate.","title":"enable_rotation"},{"location":"documentation/ref_scene/#enable_bound_aabb","text":"Whether the particle is bound by an AABB.","title":"enable_bound_aabb"},{"location":"documentation/ref_scene/#need_update_linked_list","text":"Whether the particle's linked list needs to be updated.","title":"need_update_linked_list"},{"location":"documentation/ref_scene/#linked_cell_list","text":"The linked cell list of the particle.","title":"linked_cell_list"},{"location":"documentation/ref_scene/#linked_particle_list","text":"The linked particle list of the particle.","title":"linked_particle_list"},{"location":"documentation/ref_scene/#linked_wall_list","text":"The linked wall list of the particle.","title":"linked_wall_list"},{"location":"documentation/ref_scene/#contact_pp_lookup_table","text":"The lookup table for particle-particle contact.","title":"contact_pp_lookup_table"},{"location":"documentation/ref_scene/#contact_pw_lookup_table","text":"The lookup table for particle-wall contact.","title":"contact_pw_lookup_table"},{"location":"documentation/ref_scene/#is_on_edge","text":"Whether the particle is on an edge.","title":"is_on_edge"},{"location":"documentation/ref_scene/#need_send_out","text":"Whether the particle needs to be sent out.","title":"need_send_out"},{"location":"documentation/ref_scene/#linked_domain_list","text":"The linked domain list of the particle.","title":"linked_domain_list"},{"location":"documentation/ref_scene/#need_update_stl_model","text":"Whether the particle's STL model needs to be updated.","title":"need_update_stl_model"},{"location":"documentation/ref_scene/#stl_model","text":"The STL model of the particle.","title":"stl_model"},{"location":"documentation/ref_scene/#wall","text":"This class represents a wall object.","title":"Wall"},{"location":"documentation/ref_scene/#constructor_4","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#wall_1","text":"Creates a new instance of the Wall class.","title":"Wall()"},{"location":"documentation/ref_scene/#wallshape","text":"Creates a new instance of the Wall class with a specified shape. shape (Shape): The shape of the wall.","title":"Wall(shape)"},{"location":"documentation/ref_scene/#attributes_2","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#id_1","text":"An integer ID for the wall.","title":"id"},{"location":"documentation/ref_scene/#label","text":"A string label for the wall.","title":"label"},{"location":"documentation/ref_scene/#shape_1","text":"The shape of the wall.","title":"shape"},{"location":"documentation/ref_scene/#material_type_1","text":"The material type of the wall.","title":"material_type"},{"location":"documentation/ref_scene/#enable_rotation_1","text":"A boolean indicating whether the wall is allowed to rotate.","title":"enable_rotation"},{"location":"documentation/ref_scene/#enable_bound_aabb_1","text":"A boolean indicating whether the wall has an axis-aligned bounding box.","title":"enable_bound_aabb"},{"location":"documentation/ref_scene/#bound_min_1","text":"The minimum position of the bounding box.","title":"bound_min"},{"location":"documentation/ref_scene/#bound_max_1","text":"The maximum position of the bounding box.","title":"bound_max"},{"location":"documentation/ref_scene/#bound_disp_1","text":"The displacement of the bounding box.","title":"bound_disp"},{"location":"documentation/ref_scene/#pos_1","text":"The position of the wall.","title":"pos"},{"location":"documentation/ref_scene/#quaternion_1","text":"The quaternion orientation of the wall.","title":"quaternion"},{"location":"documentation/ref_scene/#force_1","text":"The force acting on the wall.","title":"force"},{"location":"documentation/ref_scene/#moment_1","text":"The moment acting on the wall.","title":"moment"},{"location":"documentation/ref_scene/#vel_1","text":"The velocity of the wall.","title":"vel"},{"location":"documentation/ref_scene/#spin_1","text":"The spin of the wall.","title":"spin"},{"location":"documentation/ref_scene/#vel_spin","text":"The velocity spin of the wall.","title":"vel_spin"},{"location":"documentation/ref_scene/#dynamic_properties_1","text":"A map containing the dynamic properties of the wall.","title":"dynamic_properties"},{"location":"documentation/ref_scene/#need_update_linked_list_1","text":"A boolean indicating whether the wall's linked list needs to be updated.","title":"need_update_linked_list"},{"location":"documentation/ref_scene/#linked_cell_list_1","text":"A list of linked cells.","title":"linked_cell_list"},{"location":"documentation/ref_scene/#linked_particle_list_1","text":"A list of linked particles.","title":"linked_particle_list"},{"location":"documentation/ref_scene/#contact_pw_lookup_table_1","text":"A lookup table for pairwise contacts.","title":"contact_pw_lookup_table"},{"location":"documentation/ref_scene/#need_update_stl_model_1","text":"A boolean indicating whether the wall's STL model needs to be updated.","title":"need_update_stl_model"},{"location":"documentation/ref_scene/#stl_model_1","text":"The STL model of the wall.","title":"stl_model"},{"location":"documentation/ref_scene/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_scene/#setshapeshape","text":"Sets the shape of the wall. shape (Shape): The shape of the wall.","title":"SetShape(shape)"},{"location":"documentation/ref_scene/#setpositionpos","text":"Sets the position of the wall. pos (Vec3d): The position of the wall.","title":"SetPosition(pos)"},{"location":"documentation/ref_scene/#setrodriguesrot","text":"Sets the Rodrigues rotation of the wall. rot (Vec3d): The Rodrigues rotation of the wall.","title":"SetRodrigues(rot)"},{"location":"documentation/ref_scene/#setquaternionquat","text":"Sets the quaternion orientation of the wall. quat (Vec4d): The quaternion orientation of the wall.","title":"SetQuaternion(quat)"},{"location":"documentation/ref_scene/#setvelocityvel","text":"Sets the velocity of the wall. vel (Vec3d): The velocity of the wall.","title":"SetVelocity(vel)"},{"location":"documentation/ref_scene/#setspinspin","text":"Sets the spin of the wall. spin (Vec3d): The spin of the wall.","title":"SetSpin(spin)"},{"location":"documentation/ref_scene/#setvelocityspinvel-spin","text":"Sets the velocity and spin of the wall. vel (Vec3d): The velocity of the wall. spin (Vec3d): The spin of the wall.","title":"SetVelocitySpin(vel, spin)"},{"location":"documentation/ref_scene/#getvelocity","text":"Return: the velocity of the wall.","title":"GetVelocity()"},{"location":"documentation/ref_scene/#setdynamicpropertyprop_name-prop_value","text":"Sets a dynamic property of the wall. prop_name (string): The name of the dynamic property to set. prop_value (float): The value to set for the dynamic property.","title":"SetDynamicProperty(prop_name, prop_value)"},{"location":"documentation/ref_scene/#getdynamicpropertyprop_name","text":"Returns the value of a dynamic property of the wall. prop_name (string): The name of the dynamic property.","title":"GetDynamicProperty(prop_name)"},{"location":"documentation/ref_scene/#addforceforce","text":"Adds a force to the wall. force (Vec3d): The force to add.","title":"AddForce(force)"},{"location":"documentation/ref_scene/#addmomentmoment","text":"Adds a moment to the wall. moment (Vec3d): The moment to add.","title":"AddMoment(moment)"},{"location":"documentation/ref_scene/#addforcef","text":"Add a force to the wall. f (Vec3d): The force to add.","title":"AddForce(f)"},{"location":"documentation/ref_scene/#addmomentm","text":"Add a moment to the wall. m (Vec3d): The moment to add.","title":"AddMoment(m)"},{"location":"documentation/ref_scene/#addforceatomicf","text":"Add an atomic force to the wall. f (Vec3d): The atomic force to add.","title":"AddForceAtomic(f)"},{"location":"documentation/ref_scene/#addmomentatomicm","text":"Add an atomic moment to the wall. m (Vec3d): The atomic moment to add.","title":"AddMomentAtomic(m)"},{"location":"documentation/ref_scene/#clearforce","text":"Clear the total force on the wall.","title":"ClearForce()"},{"location":"documentation/ref_scene/#clearmoment","text":"Clear the total moment on the wall.","title":"ClearMoment()"},{"location":"documentation/ref_scene/#applycontactforcecontact_pw-contact_force","text":"Apply a contact force to the wall. contact_pw : The contact point on the wall. contact_force : The contact force to apply.","title":"ApplyContactForce(contact_pw, contact_force)"},{"location":"documentation/ref_scene/#updatecontactforcecontact_pw-contact_force","text":"Update the contact force on the wall. contact_pw (Vec3d): The contact point on the wall. contact_force (Vec3d): The new contact force.","title":"UpdateContactForce(contact_pw, contact_force)"},{"location":"documentation/ref_scene/#updatemotion","text":"Update the motion of the wall. t (double, optional): The time step. Default is 0.","title":"UpdateMotion()"},{"location":"documentation/ref_scene/#updatemotionpos-quat-t","text":"Update the motion of the wall. pos (Vec3d): The position of the wall. quat (Vec4d): The quaternion of the wall. t (double, optional): The time step. Default is 0.","title":"UpdateMotion(pos, quat, t)"},{"location":"documentation/ref_scene/#updatemotionpos-euler-t","text":"Update the motion of the wall. pos (Vec3d): The position of the wall. euler (Vec3d): The Euler angles of the wall. t (double, optional): The time step. Default is 0.","title":"UpdateMotion(pos, euler, t)"},{"location":"documentation/ref_scene/#updatebound","text":"Update the bounding box of the wall.","title":"UpdateBound()"},{"location":"documentation/ref_scene/#clearlinkedcells","text":"Clear the linked cells of the wall.","title":"ClearLinkedCells()"},{"location":"documentation/ref_scene/#clearlinkedneighs","text":"Clear the linked neighbors of the wall.","title":"ClearLinkedNeighs()"},{"location":"documentation/ref_scene/#buildcontactlookuptable","text":"Build the contact lookup table of the wall.","title":"BuildContactLookUpTable()"},{"location":"documentation/ref_scene/#clearcontactlookuptable","text":"Clear the contact lookup table of the wall.","title":"ClearContactLookUpTable()"},{"location":"documentation/ref_scene/#updatelinkedcells","text":"Update the linked cells of the wall.","title":"UpdateLinkedCells()"},{"location":"documentation/ref_scene/#updatelinkedneighs","text":"Update the linked neighbors of the wall.","title":"UpdateLinkedNeighs()"},{"location":"documentation/ref_scene/#getcontactpws_1","text":"Get the contact points and weights of the wall.","title":"GetContactPWs()"},{"location":"documentation/ref_scene/#updatestlmodel","text":"Update the STL model of the wall.","title":"UpdateSTLModel()"},{"location":"documentation/ref_scene/#saveasvtkfile_name","text":"Save the wall as a VTK file. file_name (string): The name of the file to save.","title":"SaveAsVTK(file_name)"},{"location":"documentation/ref_scene/#print","text":"Print the wall.","title":"Print()"},{"location":"documentation/ref_scene/#findlinked","text":"Find the linked objects of the wall.","title":"FindLinked()"},{"location":"documentation/ref_scene/#findcontactrefcontact_pw","text":"Find the contact reference object of the wall.","title":"FindContactRef(contact_pw)"},{"location":"documentation/ref_scene/#wallboxplane","text":"","title":"WallBoxPlane"},{"location":"documentation/ref_scene/#constructor_5","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#wallboxplanex-y-z-w-h-d","text":"Creates a new instance of the WallBoxPlane class with the following parameters: x (float): x coordinate of the center of the box y (float): y coordinate of the center of the box z (float): z coordinate of the center of the box w (float): width of the box h (float): height of the box d (float): depth of the box","title":"WallBoxPlane(x, y, z, w, h, d)"},{"location":"documentation/ref_scene/#methods_3","text":"","title":"Methods"},{"location":"documentation/ref_scene/#getshapes_1","text":"Returns a list of shape objects of the wall.","title":"GetShapes()"},{"location":"documentation/ref_scene/#getwalls","text":"Returns a list of wall objects of the wall.","title":"GetWalls()"},{"location":"documentation/ref_scene/#importtoscene","text":"Imports the wall object to the simulation scene.","title":"ImportToScene()"},{"location":"documentation/ref_scene/#wallboxplate","text":"These classes represent wall objects in the simulation scene, with a box shape and a plane or a plate surface.","title":"WallBoxPlate"},{"location":"documentation/ref_scene/#constructor_6","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#wallboxplatex-y-z-w-h-d","text":"Creates a new instance of the WallBoxPlate class with the following parameters: x (float): x coordinate of the center of the box y (float): y coordinate of the center of the box z (float): z coordinate of the center of the box w (float): width of the box h (float): height of the box d (float): depth of the box","title":"WallBoxPlate(x, y, z, w, h, d)"},{"location":"documentation/ref_scene/#methods_4","text":"","title":"Methods"},{"location":"documentation/ref_scene/#getshapes_2","text":"Returns a list of shape objects of the wall.","title":"GetShapes()"},{"location":"documentation/ref_scene/#getwalls_1","text":"Returns a list of wall objects of the wall.","title":"GetWalls()"},{"location":"documentation/ref_scene/#importtoscene_1","text":"Imports the wall object to the simulation scene.","title":"ImportToScene()"},{"location":"documentation/ref_scene/#bondedspheres","text":"This function initializes a PyBind11 module for the BondedSpheres class.","title":"BondedSpheres"},{"location":"documentation/ref_scene/#attributes_3","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#sphere","text":"A Sphere object representing the bonded sphere.","title":"sphere"},{"location":"documentation/ref_scene/#particle_list_1","text":"A list of Particle objects.","title":"particle_list"},{"location":"documentation/ref_scene/#contact_list","text":"A list of Contact objects.","title":"contact_list"},{"location":"documentation/ref_scene/#bond_pair_list","text":"A list of bonded particle pairs.","title":"bond_pair_list"},{"location":"documentation/ref_scene/#bond_model","text":"A reference to the BondModel object used to calculate bonds.","title":"bond_model"},{"location":"documentation/ref_scene/#methods_5","text":"","title":"Methods"},{"location":"documentation/ref_scene/#init_1","text":"The default constructor.","title":"init()"},{"location":"documentation/ref_scene/#initbondedspheres","text":"A copy constructor that initializes a BondedSpheres object from another BondedSpheres object.","title":"init(BondedSpheres)"},{"location":"documentation/ref_scene/#setbondmodel","text":"Sets the bond model used to calculate bonds.","title":"SetBondModel()"},{"location":"documentation/ref_scene/#translate","text":"Translates the BondedSpheres object.","title":"Translate()"},{"location":"documentation/ref_scene/#rotatebyrodrigues","text":"Rotates the BondedSpheres object using Rodrigues' rotation formula.","title":"RotateByRodrigues()"},{"location":"documentation/ref_scene/#getcentroid","text":"Returns the centroid of the BondedSpheres object.","title":"GetCentroid()"},{"location":"documentation/ref_scene/#initfromstl","text":"Initializes the BondedSpheres object from an STL file. filename (string): The path to the STL file. radius (float): The radius of the sphere.","title":"InitFromSTL()"},{"location":"documentation/ref_scene/#initfromgrid","text":"Initializes the BondedSpheres object from a grid.","title":"InitFromGrid()"},{"location":"documentation/ref_scene/#makeporosity","text":"Creates porosity in the BondedSpheres object.","title":"MakePorosity()"},{"location":"documentation/ref_scene/#initbonds","text":"Initializes the bonded pairs in the BondedSpheres object.","title":"InitBonds()"},{"location":"documentation/ref_scene/#importtoscene_2","text":"Imports the BondedSpheres object to a scene.","title":"ImportToScene()"},{"location":"documentation/ref_scene/#bondedvoronois","text":"This class represents a bonded Voronois object.","title":"BondedVoronois"},{"location":"documentation/ref_scene/#constructor_7","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#bondedvoronois_1","text":"Creates a new instance of the BondedVoronois class.","title":"BondedVoronois()"},{"location":"documentation/ref_scene/#attributes_4","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#trimesh_list","text":"A list of trimeshes.","title":"trimesh_list"},{"location":"documentation/ref_scene/#particle_list_2","text":"A list of particles.","title":"particle_list"},{"location":"documentation/ref_scene/#contact_list_1","text":"A list of contacts.","title":"contact_list"},{"location":"documentation/ref_scene/#bond_pair_list_1","text":"A list of bond pairs.","title":"bond_pair_list"},{"location":"documentation/ref_scene/#cvt_max_iters","text":"The maximum number of iterations for the CVT algorithm.","title":"cvt_max_iters"},{"location":"documentation/ref_scene/#cvt_tol","text":"The tolerance for the CVT algorithm.","title":"cvt_tol"},{"location":"documentation/ref_scene/#bond_model_1","text":"The bond model used by the BondedVoronois object.","title":"bond_model"},{"location":"documentation/ref_scene/#methods_6","text":"","title":"Methods"},{"location":"documentation/ref_scene/#setbondmodelbond_model","text":"Set the bond model used by the BondedVoronois object. bond_model (BondModel): The bond model to set.","title":"SetBondModel(bond_model)"},{"location":"documentation/ref_scene/#translatex-y-z","text":"Translate the BondedVoronois object. x (float): The amount to translate in the x direction. y (float): The amount to translate in the y direction. z (float): The amount to translate in the z direction.","title":"Translate(x, y, z)"},{"location":"documentation/ref_scene/#rotatebyrodriguestheta-u","text":"Rotate the BondedVoronois object by the Rodrigues formula. theta (float): The angle of rotation. u (array-like): The axis of rotation.","title":"RotateByRodrigues(theta, u)"},{"location":"documentation/ref_scene/#getcentroid_1","text":"Get the centroid of the BondedVoronois object.","title":"GetCentroid()"},{"location":"documentation/ref_scene/#initfromstlstl_file-label","text":"Initialize the BondedVoronois object from an STL file. stl_file (string): The path to the STL file. label (string, optional): A label for the object. Default is an empty string.","title":"InitFromSTL(stl_file, label='')"},{"location":"documentation/ref_scene/#makeporosityporosity","text":"Make the BondedVoronois object porous. porosity (float): The desired porosity.","title":"MakePorosity(porosity)"},{"location":"documentation/ref_scene/#initbonds_1","text":"Initialize the bonds of the BondedVoronois object.","title":"InitBonds()"},{"location":"documentation/ref_scene/#refreshpointers","text":"Refresh the pointers of the BondedVoronois object.","title":"RefreshPointers()"},{"location":"documentation/ref_scene/#saveasvtkfilename","text":"Save the BondedVoronois object as a VTK file. filename (string): The name of the VTK file.","title":"SaveAsVTK(filename)"},{"location":"documentation/ref_scene/#importtoscenescene","text":"Import the BondedVoronois object to a scene. scene (Scene): The scene to import to.","title":"ImportToScene(scene)"},{"location":"documentation/ref_scene/#contactpp","text":"This class represents a contact model between two particles.","title":"ContactPP"},{"location":"documentation/ref_scene/#constructor_8","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#contactpp_1","text":"Creates a new instance of the ContactPP class.","title":"ContactPP()"},{"location":"documentation/ref_scene/#contactppparticle_1-particle_2","text":"Creates a new instance of the ContactPP class with the given particles. particle_1 (Particle* const): Pointer to the first particle. particle_2 (Particle* const): Pointer to the second particle.","title":"ContactPP(particle_1, particle_2)"},{"location":"documentation/ref_scene/#attributes_5","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#particle_2","text":"Pointer to the first particle involved in the contact.","title":"particle_1"},{"location":"documentation/ref_scene/#particle_3","text":"Pointer to the second particle involved in the contact.","title":"particle_2"},{"location":"documentation/ref_scene/#bond_entries","text":"A vector of bond entries for the contact.","title":"bond_entries"},{"location":"documentation/ref_scene/#collision_entries","text":"A vector of collision entries for the contact.","title":"collision_entries"},{"location":"documentation/ref_scene/#active","text":"A boolean value indicating whether the contact is active or not.","title":"active"},{"location":"documentation/ref_scene/#dynamic_properties_2","text":"A dictionary of dynamic properties for the contact.","title":"dynamic_properties"},{"location":"documentation/ref_scene/#methods_7","text":"","title":"Methods"},{"location":"documentation/ref_scene/#setbondmodelbond_model_1","text":"Set the bond model for the contact. bond_model (BondModel*): Pointer to the bond model.","title":"SetBondModel(bond_model)"},{"location":"documentation/ref_scene/#setcollisionmodelcollision_model","text":"Set the collision model for the contact. collision_model (CollisionModel*): Pointer to the collision model.","title":"SetCollisionModel(collision_model)"},{"location":"documentation/ref_scene/#evaluateforcemoment","text":"Evaluate the force and moment for the contact.","title":"EvaluateForceMoment()"},{"location":"documentation/ref_scene/#applytoparticle","text":"Apply the contact force and moment to the particles.","title":"ApplyToParticle()"},{"location":"documentation/ref_scene/#applytoparticle1","text":"Apply the contact force and moment to the first particle.","title":"ApplyToParticle1()"},{"location":"documentation/ref_scene/#applytoparticle2","text":"Apply the contact force and moment to the second particle.","title":"ApplyToParticle2()"},{"location":"documentation/ref_scene/#isactive","text":"Return a boolean indicating whether the contact is active or not.","title":"IsActive()"},{"location":"documentation/ref_scene/#clear","text":"Clear the contact data.","title":"Clear()"},{"location":"documentation/ref_scene/#print_1","text":"Print the contact data.","title":"Print()"},{"location":"documentation/ref_scene/#contactpw","text":"This class represents a contact between a particle and a wall.","title":"ContactPW"},{"location":"documentation/ref_scene/#constructor_9","text":"","title":"Constructor"},{"location":"documentation/ref_scene/#contactpwparticle-wall","text":"Creates a new instance of the ContactPW class with a given particle and wall. particle (Particle object): The particle involved in the contact. wall (Wall object): The wall involved in the contact.","title":"ContactPW(particle, wall)"},{"location":"documentation/ref_scene/#attributes_6","text":"","title":"Attributes"},{"location":"documentation/ref_scene/#particle_4","text":"The particle involved in the contact.","title":"particle"},{"location":"documentation/ref_scene/#wall_2","text":"The wall involved in the contact.","title":"wall"},{"location":"documentation/ref_scene/#bond_model_2","text":"The bond model used for the contact.","title":"bond_model"},{"location":"documentation/ref_scene/#collision_model","text":"The collision model used for the contact.","title":"collision_model"},{"location":"documentation/ref_scene/#bond_entries_1","text":"A list of bond entries for the contact.","title":"bond_entries"},{"location":"documentation/ref_scene/#collision_entries_1","text":"A list of collision entries for the contact.","title":"collision_entries"},{"location":"documentation/ref_scene/#active_1","text":"A boolean flag indicating whether the contact is currently active.","title":"active"},{"location":"documentation/ref_scene/#dynamic_properties_3","text":"A dictionary of dynamic properties associated with the contact.","title":"dynamic_properties"},{"location":"documentation/ref_scene/#methods_8","text":"","title":"Methods"},{"location":"documentation/ref_scene/#setbondmodelbond_model_2","text":"Set the bond model for the contact. bond_model (BondModel object): The bond model to use for the contact.","title":"SetBondModel(bond_model)"},{"location":"documentation/ref_scene/#setcollisionmodelcollision_model_1","text":"Set the collision model for the contact. collision_model (CollisionModel object): The collision model to use for the contact.","title":"SetCollisionModel(collision_model)"},{"location":"documentation/ref_scene/#evaluateforcemoment_1","text":"Calculate and return the force and moment of the contact.","title":"EvaluateForceMoment()"},{"location":"documentation/ref_scene/#applytoparticle_1","text":"Apply the contact to the particle involved in the contact.","title":"ApplyToParticle()"},{"location":"documentation/ref_scene/#applytowall","text":"Apply the contact to the wall involved in the contact.","title":"ApplyToWall()"},{"location":"documentation/ref_scene/#isactive_1","text":"Return True if the contact is currently active, False otherwise.","title":"IsActive()"},{"location":"documentation/ref_scene/#clear_1","text":"Clear all bond and collision entries for the contact.","title":"Clear()"},{"location":"documentation/ref_scene/#print_2","text":"Print information about the contact. User manual \u250a Previous \u250a Next","title":"Print()"},{"location":"documentation/ref_shape/","text":"User manual \u250a Previous \u250a Next Shape This class represents a shape. Constructor Shape() Creates a new instance of the Shape class. Attributes id An integer ID for the shape. label A string label for the shape. shape_type An enumeration representing the type of the shape. shape_name A string name for the shape. size A Vec3d vector representing the size of the shape. volume A double representing the volume of the shape. inertia A Vec3d vector representing the inertia tensor of the shape. bound_sphere_radius A double representing the radius of the bounding sphere of the shape. skin A bool indicating whether the shape has a skin. skin_factor A double representing the skin factor of the shape. bound_aabb_min A Vec3d vector representing the minimum corner of the axis-aligned bounding box of the shape. bound_aabb_max A Vec3d vector representing the maximum corner of the axis-aligned bounding box of the shape. use_node A bool indicating whether the shape uses a node. node_num An integer representing the number of nodes used by the shape. node_spacing A double representing the spacing between nodes of the shape. nodes A vector of Vec3d vectors representing the nodes of the shape. is_convex A bool indicating whether the shape is convex. use_customized_solver A bool indicating whether the shape uses a customized solver. Methods PackJson() Pack the shape data into a JSON object. InitFromJson(json_data) Initialize the shape from a JSON object. json_data (JSON object): A JSON object containing the data to initialize the shape. InitFromJsonFile(json_file) Initialize the shape from a JSON file. json_file (string): The path of the JSON file to load. UpdateNodes() Update the nodes of the shape. UpdateShapeProperties() Update the properties of the shape. SetSize(size) Set the size of the shape. size (Vec3d): The new size of the shape. Clone() Create a new instance of the shape that is a copy of the current shape. GetSTLModel() Get the STL model of the shape. SaveAsVTK(filename) Save the shape as a VTK file. filename (string): The path of the file to save. SaveAsSTL(filename) Save the shape as an STL file. filename (string): The path of the file to save. GetBoundAABB() Get the axis-aligned bounding box of the shape. SignedDistance(point) Compute the signed distance between a point and the surface of the shape. point (Vec3d): The point to compute the signed distance from. SurfacePoint(point) Find the surface point of the shape closest to a given point. point (Vec3d): The point to find the closest surface point to. Enclose(shapes) Create a new shape that encloses a set of shapes. shapes (vector of Shape objects): The set of shapes to enclose. Print() Print the properties of the shape to the console. Sphere Represents a sphere. Constructor Sphere() Creates a new instance of the Sphere class. Sphere(radius: float) Creates a new instance of the Sphere class with the given radius. radius (float): The radius of the sphere. PointSphere Represents a point sphere. Constructor PointSphere() Creates a new instance of the PointSphere class. PointSphere(radius: float) Creates a new instance of the PointSphere class with the given radius. radius (float): The radius of the point sphere. Plane Represents a plane. Constructor Plane() Creates a new instance of the Plane class. Plane(center: Vec3d, dir_n: Vec3d, extent: float) Creates a new instance of the Plane class with the given center, normal vector, and extent. center (Vec3d): The center point of the plane. dir_n (Vec3d): The normal vector of the plane. extent (float): The extent of the plane. Attributes center The center point of the plane. dir_n The normal vector of the plane. extent The extent of the plane. Methods SetExtent(extent: float) Sets the extent of the plane. extent (float): The extent to set for the plane. SetCenter(center: Vec3d) Sets the center point of the plane. center (Vec3d): The center point to set for the plane. SetNormal(dir_n: Vec3d) Sets the normal vector of the plane. dir_n (Vec3d): The normal vector to set for the plane. Triangle Represents a triangle. Constructor Triangle() Creates a new instance of the Triangle class. Triangle(v1: Vec3d, v2: Vec3d, v3: Vec3d) Creates a new instance of the Triangle class with the given vertices. v1 (Vec3d): The first vertex of the triangle. v2 (Vec3d): The second vertex of the triangle. v3 (Vec3d): The third vertex of the triangle. Attributes vertices The vertices of the triangle. dir_n The normal vector of the triangle. Methods SetVertices(v1: Vec3d, v2: Vec3d, v3: Vec3d) Sets the vertices of the triangle. v1 (Vec3d): The first vertex of the triangle. v2 (Vec3d): The second vertex of the triangle. v3 (Vec3d): The third vertex of the triangle. Cylinder This class represents a cylinder. Constructor Cylinder() Creates a new instance of the Cylinder class with default values. Cylinder(radius, height) Creates a new instance of the Cylinder class with the given radius and height values. Attributes radius The radius of the cylinder. height The height of the cylinder. Methods Init() Initializes the cylinder with default values. Init(radius, height) Initializes the cylinder with the given radius and height values. Ellipsoid This class represents an ellipsoid. Constructor Ellipsoid() Creates a new instance of the Ellipsoid class with default values. Ellipsoid(axis_a, axis_b, axis_c) Creates a new instance of the Ellipsoid class with the given axis_a, axis_b, and axis_c values. Attributes axis_a The length of the semi-axis along the x-axis. axis_b The length of the semi-axis along the y-axis. axis_c The length of the semi-axis along the z-axis. Methods Init() Initializes the ellipsoid with default values. Init(axis_a, axis_b, axis_c) Initializes the ellipsoid with the given axis_a, axis_b, and axis_c values. SphericalHarmonics This class represents a spherical harmonics shape. Constructor SphericalHarmonics() Creates a new instance of the SphericalHarmonics class with default values. SphericalHarmonics(degree) Creates a new instance of the SphericalHarmonics class with the given degree value. Attributes degree The degree of the spherical harmonics shape. a_nm The coefficients of the spherical harmonics shape. Methods Init() Initializes the spherical harmonics shape with default values. Init(degree) Initializes the spherical harmonics shape with the given degree value. InitFromSTL(file_path) Initializes the spherical harmonics shape from an STL file located at file_path. InitFromSTL(stl_model) Initializes the spherical harmonics shape from an STLModel object stl_model. PolySuperEllipsoid This class represents a poly super ellipsoid shape. Constructor PolySuperEllipsoid() Creates a new instance of the PolySuperEllipsoid class. Attributes axis_a The axis a value of the poly super ellipsoid. axis_b The axis b value of the poly super ellipsoid. axis_c The axis c value of the poly super ellipsoid. order_ab The order ab value of the poly super ellipsoid. order_c The order c value of the poly super ellipsoid. Methods Init(axis_a, axis_b, axis_c, order_ab, order_c) Initializes the poly super ellipsoid with the given parameters. axis_a (float): The axis a value to set. axis_b (float): The axis b value to set. axis_c (float): The axis c value to set. order_ab (float): The order ab value to set. order_c (float): The order c value to set. PolySuperQuadrics This class represents a poly superquadric shape. Constructor PolySuperQuadrics (axis_a=1, axis_b=1, axis_c=1, order_a=2, order_b=2, order_c=2, x=0, y=0, z=0, qx=0, qy=0, qz=0) Creates a new instance of the PolySuperQuadrics class. axis_a (float, optional): The scaling factor for the x axis. Default is 1. axis_b (float, optional): The scaling factor for the y axis. Default is 1. axis_c (float, optional): The scaling factor for the z axis. Default is 1. order_a (float, optional): The order of the polynomial for the x axis. Default is 2. order_b (float, optional): The order of the polynomial for the y axis. Default is 2. order_c (float, optional): The order of the polynomial for the z axis. Default is 2. x (float, optional): The x-coordinate of the position. Default is 0. y (float, optional): The y-coordinate of the position. Default is 0. z (float, optional): The z-coordinate of the position. Default is 0. qx (float, optional): The x-component of the rotation quaternion. Default is 0. qy (float, optional): The y-component of the rotation quaternion. Default is 0. qz (float, optional): The z-component of the rotation quaternion. Default is 0. Attributes axis_a The scaling factor for the x axis. axis_b The scaling factor for the y axis. axis_c The scaling factor for the z axis. order_a The order of the polynomial for the x axis. order_b The order of the polynomial for the y axis. order_c The order of the polynomial for the z axis. Methods Init() Initialize the poly superquadric shape. InitFromJSON(json_data) Initialize the poly superquadric shape from a JSON object. json_data (JSON object): A JSON object containing the parameters to set. Init(axis_a, axis_b, axis_c, order_a, order_b, order_c) Initialize the poly superquadric shape. axis_a (float): The scaling factor for the x axis. axis_b (float): The scaling factor for the y axis. axis_c (float): The scaling factor for the z axis. order_a (float): The order of the polynomial for the x axis. order_b (float): The order of the polynomial for the y axis. order_c (float): The order of the polynomial for the z axis. LevelSet This class represents a level set. Constructor LevelSet() Creates a new instance of the LevelSet class. Methods InitFromSTL(stl_file, sign) Initialize the level set from an STL file. stl_file (string): The name of the STL file. sign (int): The sign of the level set. InitFromSTL(stl_model, sign) Initialize the level set from an STL model. stl_model (STLModel): The STL model. sign (int): The sign of the level set. InitFromDistanceMap(distance_map) Initialize the level set from a distance map. distance_map : The distance map. SurfacePoint(point) Get the surface point of the level set. point (Vector3d): The point. AlignAxes() Align the axes of the level set. TriMesh This class represents a triangular mesh. Constructor TriMesh() Creates a new instance of the TriMesh class. Attributes vertices A list of vertices that make up the mesh. facets A list of facets that make up the mesh. Methods Init() Initialize the triangular mesh. InitFromSTL(file_name) Initialize the triangular mesh from an STL file. file_name (string): The name of the STL file. InitFromOFF(file_name) Initialize the triangular mesh from an OFF file. file_name (string): The name of the OFF file. Decimate(num_faces) Decimate the mesh to reduce the number of faces. num_faces (int): The target number of faces for the decimated mesh. MakeConvex() Make the mesh convex. AlignAxes() Align the axes of the mesh. InitPyShapeModule This function initializes a Python module with various shape classes and functions. The following functions are called to add their respective classes to the module: InitPyShape InitPySphere InitPyPointSphere InitPyPlane InitPyTriangle InitPyCylinder InitPyEllipsoid InitPySphericalHarmonics InitPyPolySuperEllipsoid InitPyPolySuperQuadrics InitPyLevelSet InitPyTriMesh User manual \u250a Previous \u250a Next","title":"Ref shape"},{"location":"documentation/ref_shape/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_shape/#shape","text":"This class represents a shape.","title":"Shape"},{"location":"documentation/ref_shape/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#shape_1","text":"Creates a new instance of the Shape class.","title":"Shape()"},{"location":"documentation/ref_shape/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#id","text":"An integer ID for the shape.","title":"id"},{"location":"documentation/ref_shape/#label","text":"A string label for the shape.","title":"label"},{"location":"documentation/ref_shape/#shape_type","text":"An enumeration representing the type of the shape.","title":"shape_type"},{"location":"documentation/ref_shape/#shape_name","text":"A string name for the shape.","title":"shape_name"},{"location":"documentation/ref_shape/#size","text":"A Vec3d vector representing the size of the shape.","title":"size"},{"location":"documentation/ref_shape/#volume","text":"A double representing the volume of the shape.","title":"volume"},{"location":"documentation/ref_shape/#inertia","text":"A Vec3d vector representing the inertia tensor of the shape.","title":"inertia"},{"location":"documentation/ref_shape/#bound_sphere_radius","text":"A double representing the radius of the bounding sphere of the shape.","title":"bound_sphere_radius"},{"location":"documentation/ref_shape/#skin","text":"A bool indicating whether the shape has a skin.","title":"skin"},{"location":"documentation/ref_shape/#skin_factor","text":"A double representing the skin factor of the shape.","title":"skin_factor"},{"location":"documentation/ref_shape/#bound_aabb_min","text":"A Vec3d vector representing the minimum corner of the axis-aligned bounding box of the shape.","title":"bound_aabb_min"},{"location":"documentation/ref_shape/#bound_aabb_max","text":"A Vec3d vector representing the maximum corner of the axis-aligned bounding box of the shape.","title":"bound_aabb_max"},{"location":"documentation/ref_shape/#use_node","text":"A bool indicating whether the shape uses a node.","title":"use_node"},{"location":"documentation/ref_shape/#node_num","text":"An integer representing the number of nodes used by the shape.","title":"node_num"},{"location":"documentation/ref_shape/#node_spacing","text":"A double representing the spacing between nodes of the shape.","title":"node_spacing"},{"location":"documentation/ref_shape/#nodes","text":"A vector of Vec3d vectors representing the nodes of the shape.","title":"nodes"},{"location":"documentation/ref_shape/#is_convex","text":"A bool indicating whether the shape is convex.","title":"is_convex"},{"location":"documentation/ref_shape/#use_customized_solver","text":"A bool indicating whether the shape uses a customized solver.","title":"use_customized_solver"},{"location":"documentation/ref_shape/#methods","text":"","title":"Methods"},{"location":"documentation/ref_shape/#packjson","text":"Pack the shape data into a JSON object.","title":"PackJson()"},{"location":"documentation/ref_shape/#initfromjsonjson_data","text":"Initialize the shape from a JSON object. json_data (JSON object): A JSON object containing the data to initialize the shape.","title":"InitFromJson(json_data)"},{"location":"documentation/ref_shape/#initfromjsonfilejson_file","text":"Initialize the shape from a JSON file. json_file (string): The path of the JSON file to load.","title":"InitFromJsonFile(json_file)"},{"location":"documentation/ref_shape/#updatenodes","text":"Update the nodes of the shape.","title":"UpdateNodes()"},{"location":"documentation/ref_shape/#updateshapeproperties","text":"Update the properties of the shape.","title":"UpdateShapeProperties()"},{"location":"documentation/ref_shape/#setsizesize","text":"Set the size of the shape. size (Vec3d): The new size of the shape.","title":"SetSize(size)"},{"location":"documentation/ref_shape/#clone","text":"Create a new instance of the shape that is a copy of the current shape.","title":"Clone()"},{"location":"documentation/ref_shape/#getstlmodel","text":"Get the STL model of the shape.","title":"GetSTLModel()"},{"location":"documentation/ref_shape/#saveasvtkfilename","text":"Save the shape as a VTK file. filename (string): The path of the file to save.","title":"SaveAsVTK(filename)"},{"location":"documentation/ref_shape/#saveasstlfilename","text":"Save the shape as an STL file. filename (string): The path of the file to save.","title":"SaveAsSTL(filename)"},{"location":"documentation/ref_shape/#getboundaabb","text":"Get the axis-aligned bounding box of the shape.","title":"GetBoundAABB()"},{"location":"documentation/ref_shape/#signeddistancepoint","text":"Compute the signed distance between a point and the surface of the shape. point (Vec3d): The point to compute the signed distance from.","title":"SignedDistance(point)"},{"location":"documentation/ref_shape/#surfacepointpoint","text":"Find the surface point of the shape closest to a given point. point (Vec3d): The point to find the closest surface point to.","title":"SurfacePoint(point)"},{"location":"documentation/ref_shape/#encloseshapes","text":"Create a new shape that encloses a set of shapes. shapes (vector of Shape objects): The set of shapes to enclose.","title":"Enclose(shapes)"},{"location":"documentation/ref_shape/#print","text":"Print the properties of the shape to the console.","title":"Print()"},{"location":"documentation/ref_shape/#sphere","text":"Represents a sphere.","title":"Sphere"},{"location":"documentation/ref_shape/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#sphere_1","text":"Creates a new instance of the Sphere class.","title":"Sphere()"},{"location":"documentation/ref_shape/#sphereradius-float","text":"Creates a new instance of the Sphere class with the given radius. radius (float): The radius of the sphere.","title":"Sphere(radius: float)"},{"location":"documentation/ref_shape/#pointsphere","text":"Represents a point sphere.","title":"PointSphere"},{"location":"documentation/ref_shape/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#pointsphere_1","text":"Creates a new instance of the PointSphere class.","title":"PointSphere()"},{"location":"documentation/ref_shape/#pointsphereradius-float","text":"Creates a new instance of the PointSphere class with the given radius. radius (float): The radius of the point sphere.","title":"PointSphere(radius: float)"},{"location":"documentation/ref_shape/#plane","text":"Represents a plane.","title":"Plane"},{"location":"documentation/ref_shape/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#plane_1","text":"Creates a new instance of the Plane class.","title":"Plane()"},{"location":"documentation/ref_shape/#planecenter-vec3d-dir_n-vec3d-extent-float","text":"Creates a new instance of the Plane class with the given center, normal vector, and extent. center (Vec3d): The center point of the plane. dir_n (Vec3d): The normal vector of the plane. extent (float): The extent of the plane. Attributes","title":"Plane(center: Vec3d, dir_n: Vec3d, extent: float)"},{"location":"documentation/ref_shape/#center","text":"The center point of the plane.","title":"center"},{"location":"documentation/ref_shape/#dir_n","text":"The normal vector of the plane.","title":"dir_n"},{"location":"documentation/ref_shape/#extent","text":"The extent of the plane. Methods","title":"extent"},{"location":"documentation/ref_shape/#setextentextent-float","text":"Sets the extent of the plane. extent (float): The extent to set for the plane.","title":"SetExtent(extent: float)"},{"location":"documentation/ref_shape/#setcentercenter-vec3d","text":"Sets the center point of the plane. center (Vec3d): The center point to set for the plane.","title":"SetCenter(center: Vec3d)"},{"location":"documentation/ref_shape/#setnormaldir_n-vec3d","text":"Sets the normal vector of the plane. dir_n (Vec3d): The normal vector to set for the plane.","title":"SetNormal(dir_n: Vec3d)"},{"location":"documentation/ref_shape/#triangle","text":"Represents a triangle.","title":"Triangle"},{"location":"documentation/ref_shape/#constructor_4","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#triangle_1","text":"Creates a new instance of the Triangle class.","title":"Triangle()"},{"location":"documentation/ref_shape/#trianglev1-vec3d-v2-vec3d-v3-vec3d","text":"Creates a new instance of the Triangle class with the given vertices. v1 (Vec3d): The first vertex of the triangle. v2 (Vec3d): The second vertex of the triangle. v3 (Vec3d): The third vertex of the triangle.","title":"Triangle(v1: Vec3d, v2: Vec3d, v3: Vec3d)"},{"location":"documentation/ref_shape/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#vertices","text":"The vertices of the triangle.","title":"vertices"},{"location":"documentation/ref_shape/#dir_n_1","text":"The normal vector of the triangle.","title":"dir_n"},{"location":"documentation/ref_shape/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_shape/#setverticesv1-vec3d-v2-vec3d-v3-vec3d","text":"Sets the vertices of the triangle. v1 (Vec3d): The first vertex of the triangle. v2 (Vec3d): The second vertex of the triangle. v3 (Vec3d): The third vertex of the triangle.","title":"SetVertices(v1: Vec3d, v2: Vec3d, v3: Vec3d)"},{"location":"documentation/ref_shape/#cylinder","text":"This class represents a cylinder.","title":"Cylinder"},{"location":"documentation/ref_shape/#constructor_5","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#cylinder_1","text":"Creates a new instance of the Cylinder class with default values.","title":"Cylinder()"},{"location":"documentation/ref_shape/#cylinderradius-height","text":"Creates a new instance of the Cylinder class with the given radius and height values.","title":"Cylinder(radius, height)"},{"location":"documentation/ref_shape/#attributes_2","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#radius","text":"The radius of the cylinder.","title":"radius"},{"location":"documentation/ref_shape/#height","text":"The height of the cylinder.","title":"height"},{"location":"documentation/ref_shape/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_shape/#init","text":"Initializes the cylinder with default values.","title":"Init()"},{"location":"documentation/ref_shape/#initradius-height","text":"Initializes the cylinder with the given radius and height values.","title":"Init(radius, height)"},{"location":"documentation/ref_shape/#ellipsoid","text":"This class represents an ellipsoid.","title":"Ellipsoid"},{"location":"documentation/ref_shape/#constructor_6","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#ellipsoid_1","text":"Creates a new instance of the Ellipsoid class with default values.","title":"Ellipsoid()"},{"location":"documentation/ref_shape/#ellipsoidaxis_a-axis_b-axis_c","text":"Creates a new instance of the Ellipsoid class with the given axis_a, axis_b, and axis_c values.","title":"Ellipsoid(axis_a, axis_b, axis_c)"},{"location":"documentation/ref_shape/#attributes_3","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#axis_a","text":"The length of the semi-axis along the x-axis.","title":"axis_a"},{"location":"documentation/ref_shape/#axis_b","text":"The length of the semi-axis along the y-axis.","title":"axis_b"},{"location":"documentation/ref_shape/#axis_c","text":"The length of the semi-axis along the z-axis.","title":"axis_c"},{"location":"documentation/ref_shape/#methods_3","text":"","title":"Methods"},{"location":"documentation/ref_shape/#init_1","text":"Initializes the ellipsoid with default values.","title":"Init()"},{"location":"documentation/ref_shape/#initaxis_a-axis_b-axis_c","text":"Initializes the ellipsoid with the given axis_a, axis_b, and axis_c values.","title":"Init(axis_a, axis_b, axis_c)"},{"location":"documentation/ref_shape/#sphericalharmonics","text":"This class represents a spherical harmonics shape.","title":"SphericalHarmonics"},{"location":"documentation/ref_shape/#constructor_7","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#sphericalharmonics_1","text":"Creates a new instance of the SphericalHarmonics class with default values.","title":"SphericalHarmonics()"},{"location":"documentation/ref_shape/#sphericalharmonicsdegree","text":"Creates a new instance of the SphericalHarmonics class with the given degree value.","title":"SphericalHarmonics(degree)"},{"location":"documentation/ref_shape/#attributes_4","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#degree","text":"The degree of the spherical harmonics shape.","title":"degree"},{"location":"documentation/ref_shape/#a_nm","text":"The coefficients of the spherical harmonics shape.","title":"a_nm"},{"location":"documentation/ref_shape/#methods_4","text":"","title":"Methods"},{"location":"documentation/ref_shape/#init_2","text":"Initializes the spherical harmonics shape with default values.","title":"Init()"},{"location":"documentation/ref_shape/#initdegree","text":"Initializes the spherical harmonics shape with the given degree value.","title":"Init(degree)"},{"location":"documentation/ref_shape/#initfromstlfile_path","text":"Initializes the spherical harmonics shape from an STL file located at file_path.","title":"InitFromSTL(file_path)"},{"location":"documentation/ref_shape/#initfromstlstl_model","text":"Initializes the spherical harmonics shape from an STLModel object stl_model.","title":"InitFromSTL(stl_model)"},{"location":"documentation/ref_shape/#polysuperellipsoid","text":"This class represents a poly super ellipsoid shape.","title":"PolySuperEllipsoid"},{"location":"documentation/ref_shape/#constructor_8","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#polysuperellipsoid_1","text":"Creates a new instance of the PolySuperEllipsoid class.","title":"PolySuperEllipsoid()"},{"location":"documentation/ref_shape/#attributes_5","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#axis_a_1","text":"The axis a value of the poly super ellipsoid.","title":"axis_a"},{"location":"documentation/ref_shape/#axis_b_1","text":"The axis b value of the poly super ellipsoid.","title":"axis_b"},{"location":"documentation/ref_shape/#axis_c_1","text":"The axis c value of the poly super ellipsoid.","title":"axis_c"},{"location":"documentation/ref_shape/#order_ab","text":"The order ab value of the poly super ellipsoid.","title":"order_ab"},{"location":"documentation/ref_shape/#order_c","text":"The order c value of the poly super ellipsoid.","title":"order_c"},{"location":"documentation/ref_shape/#methods_5","text":"","title":"Methods"},{"location":"documentation/ref_shape/#initaxis_a-axis_b-axis_c-order_ab-order_c","text":"Initializes the poly super ellipsoid with the given parameters. axis_a (float): The axis a value to set. axis_b (float): The axis b value to set. axis_c (float): The axis c value to set. order_ab (float): The order ab value to set. order_c (float): The order c value to set.","title":"Init(axis_a, axis_b, axis_c, order_ab, order_c)"},{"location":"documentation/ref_shape/#polysuperquadrics","text":"This class represents a poly superquadric shape.","title":"PolySuperQuadrics"},{"location":"documentation/ref_shape/#constructor_9","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#polysuperquadrics_1","text":"(axis_a=1, axis_b=1, axis_c=1, order_a=2, order_b=2, order_c=2, x=0, y=0, z=0, qx=0, qy=0, qz=0) Creates a new instance of the PolySuperQuadrics class. axis_a (float, optional): The scaling factor for the x axis. Default is 1. axis_b (float, optional): The scaling factor for the y axis. Default is 1. axis_c (float, optional): The scaling factor for the z axis. Default is 1. order_a (float, optional): The order of the polynomial for the x axis. Default is 2. order_b (float, optional): The order of the polynomial for the y axis. Default is 2. order_c (float, optional): The order of the polynomial for the z axis. Default is 2. x (float, optional): The x-coordinate of the position. Default is 0. y (float, optional): The y-coordinate of the position. Default is 0. z (float, optional): The z-coordinate of the position. Default is 0. qx (float, optional): The x-component of the rotation quaternion. Default is 0. qy (float, optional): The y-component of the rotation quaternion. Default is 0. qz (float, optional): The z-component of the rotation quaternion. Default is 0.","title":"PolySuperQuadrics"},{"location":"documentation/ref_shape/#attributes_6","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#axis_a_2","text":"The scaling factor for the x axis.","title":"axis_a"},{"location":"documentation/ref_shape/#axis_b_2","text":"The scaling factor for the y axis.","title":"axis_b"},{"location":"documentation/ref_shape/#axis_c_2","text":"The scaling factor for the z axis.","title":"axis_c"},{"location":"documentation/ref_shape/#order_a","text":"The order of the polynomial for the x axis.","title":"order_a"},{"location":"documentation/ref_shape/#order_b","text":"The order of the polynomial for the y axis.","title":"order_b"},{"location":"documentation/ref_shape/#order_c_1","text":"The order of the polynomial for the z axis.","title":"order_c"},{"location":"documentation/ref_shape/#methods_6","text":"","title":"Methods"},{"location":"documentation/ref_shape/#init_3","text":"Initialize the poly superquadric shape.","title":"Init()"},{"location":"documentation/ref_shape/#initfromjsonjson_data_1","text":"Initialize the poly superquadric shape from a JSON object. json_data (JSON object): A JSON object containing the parameters to set.","title":"InitFromJSON(json_data)"},{"location":"documentation/ref_shape/#initaxis_a-axis_b-axis_c-order_a-order_b-order_c","text":"Initialize the poly superquadric shape. axis_a (float): The scaling factor for the x axis. axis_b (float): The scaling factor for the y axis. axis_c (float): The scaling factor for the z axis. order_a (float): The order of the polynomial for the x axis. order_b (float): The order of the polynomial for the y axis. order_c (float): The order of the polynomial for the z axis.","title":"Init(axis_a, axis_b, axis_c, order_a, order_b, order_c)"},{"location":"documentation/ref_shape/#levelset","text":"This class represents a level set.","title":"LevelSet"},{"location":"documentation/ref_shape/#constructor_10","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#levelset_1","text":"Creates a new instance of the LevelSet class.","title":"LevelSet()"},{"location":"documentation/ref_shape/#methods_7","text":"","title":"Methods"},{"location":"documentation/ref_shape/#initfromstlstl_file-sign","text":"Initialize the level set from an STL file. stl_file (string): The name of the STL file. sign (int): The sign of the level set.","title":"InitFromSTL(stl_file, sign)"},{"location":"documentation/ref_shape/#initfromstlstl_model-sign","text":"Initialize the level set from an STL model. stl_model (STLModel): The STL model. sign (int): The sign of the level set.","title":"InitFromSTL(stl_model, sign)"},{"location":"documentation/ref_shape/#initfromdistancemapdistance_map","text":"Initialize the level set from a distance map. distance_map : The distance map.","title":"InitFromDistanceMap(distance_map)"},{"location":"documentation/ref_shape/#surfacepointpoint_1","text":"Get the surface point of the level set. point (Vector3d): The point.","title":"SurfacePoint(point)"},{"location":"documentation/ref_shape/#alignaxes","text":"Align the axes of the level set.","title":"AlignAxes()"},{"location":"documentation/ref_shape/#trimesh","text":"This class represents a triangular mesh.","title":"TriMesh"},{"location":"documentation/ref_shape/#constructor_11","text":"","title":"Constructor"},{"location":"documentation/ref_shape/#trimesh_1","text":"Creates a new instance of the TriMesh class.","title":"TriMesh()"},{"location":"documentation/ref_shape/#attributes_7","text":"","title":"Attributes"},{"location":"documentation/ref_shape/#vertices_1","text":"A list of vertices that make up the mesh.","title":"vertices"},{"location":"documentation/ref_shape/#facets","text":"A list of facets that make up the mesh.","title":"facets"},{"location":"documentation/ref_shape/#methods_8","text":"","title":"Methods"},{"location":"documentation/ref_shape/#init_4","text":"Initialize the triangular mesh.","title":"Init()"},{"location":"documentation/ref_shape/#initfromstlfile_name","text":"Initialize the triangular mesh from an STL file. file_name (string): The name of the STL file.","title":"InitFromSTL(file_name)"},{"location":"documentation/ref_shape/#initfromofffile_name","text":"Initialize the triangular mesh from an OFF file. file_name (string): The name of the OFF file.","title":"InitFromOFF(file_name)"},{"location":"documentation/ref_shape/#decimatenum_faces","text":"Decimate the mesh to reduce the number of faces. num_faces (int): The target number of faces for the decimated mesh.","title":"Decimate(num_faces)"},{"location":"documentation/ref_shape/#makeconvex","text":"Make the mesh convex.","title":"MakeConvex()"},{"location":"documentation/ref_shape/#alignaxes_1","text":"Align the axes of the mesh.","title":"AlignAxes()"},{"location":"documentation/ref_shape/#initpyshapemodule","text":"This function initializes a Python module with various shape classes and functions. The following functions are called to add their respective classes to the module:","title":"InitPyShapeModule"},{"location":"documentation/ref_shape/#initpyshape","text":"","title":"InitPyShape"},{"location":"documentation/ref_shape/#initpysphere","text":"","title":"InitPySphere"},{"location":"documentation/ref_shape/#initpypointsphere","text":"","title":"InitPyPointSphere"},{"location":"documentation/ref_shape/#initpyplane","text":"","title":"InitPyPlane"},{"location":"documentation/ref_shape/#initpytriangle","text":"","title":"InitPyTriangle"},{"location":"documentation/ref_shape/#initpycylinder","text":"","title":"InitPyCylinder"},{"location":"documentation/ref_shape/#initpyellipsoid","text":"","title":"InitPyEllipsoid"},{"location":"documentation/ref_shape/#initpysphericalharmonics","text":"","title":"InitPySphericalHarmonics"},{"location":"documentation/ref_shape/#initpypolysuperellipsoid","text":"","title":"InitPyPolySuperEllipsoid"},{"location":"documentation/ref_shape/#initpypolysuperquadrics","text":"","title":"InitPyPolySuperQuadrics"},{"location":"documentation/ref_shape/#initpylevelset","text":"","title":"InitPyLevelSet"},{"location":"documentation/ref_shape/#initpytrimesh","text":"User manual \u250a Previous \u250a Next","title":"InitPyTriMesh"},{"location":"documentation/ref_simulation/","text":"User manual \u250a Previous \u250a Next Simulation This class represents a simulation. Attributes domain_manager The domain manager used in the simulation. mpi_manager The MPI manager used in the simulation. modifier_manager The modifier manager used in the simulation. scene The scene used in the simulation. dem_solver The DEM solver used in the simulation. mech_time The mechanical time used in the simulation. mech_cycles The mechanical cycles used in the simulation. enable_logging A flag indicating whether logging is enabled for the simulation. Methods Run() Run the simulation. AutoReadRestart() Automatically read the restart file for the simulation. SetTimeAndCycles() (time, cycles) Set the mechanical time and cycles for the simulation. time (float): The mechanical time to set. cycles (int): The mechanical cycles to set. User manual \u250a Previous \u250a Next","title":"Ref simulation"},{"location":"documentation/ref_simulation/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/ref_simulation/#simulation","text":"This class represents a simulation.","title":"Simulation"},{"location":"documentation/ref_simulation/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_simulation/#domain_manager","text":"The domain manager used in the simulation.","title":"domain_manager"},{"location":"documentation/ref_simulation/#mpi_manager","text":"The MPI manager used in the simulation.","title":"mpi_manager"},{"location":"documentation/ref_simulation/#modifier_manager","text":"The modifier manager used in the simulation.","title":"modifier_manager"},{"location":"documentation/ref_simulation/#scene","text":"The scene used in the simulation.","title":"scene"},{"location":"documentation/ref_simulation/#dem_solver","text":"The DEM solver used in the simulation.","title":"dem_solver"},{"location":"documentation/ref_simulation/#mech_time","text":"The mechanical time used in the simulation.","title":"mech_time"},{"location":"documentation/ref_simulation/#mech_cycles","text":"The mechanical cycles used in the simulation.","title":"mech_cycles"},{"location":"documentation/ref_simulation/#enable_logging","text":"A flag indicating whether logging is enabled for the simulation.","title":"enable_logging"},{"location":"documentation/ref_simulation/#methods","text":"","title":"Methods"},{"location":"documentation/ref_simulation/#run","text":"Run the simulation.","title":"Run()"},{"location":"documentation/ref_simulation/#autoreadrestart","text":"Automatically read the restart file for the simulation.","title":"AutoReadRestart()"},{"location":"documentation/ref_simulation/#settimeandcyclestime-cycles","text":"Set the mechanical time and cycles for the simulation. time (float): The mechanical time to set. cycles (int): The mechanical cycles to set. User manual \u250a Previous \u250a Next","title":"SetTimeAndCycles()(time, cycles)"},{"location":"documentation/ref_utils/","text":"User manual \u250a Previous LevelSetFunction This class represents a level set function. Constructor LevelSetFunction() Creates a new instance of the LevelSetFunction class. Attributes corner A vector representing the corner of the level set function. spacing A vector representing the spacing of the level set function. dim An integer representing the dimension of the level set function. Methods SetCorner(corner) Set the corner of the level set function. corner (vector): A vector representing the corner to set. SetSpacing(spacing) Set the spacing of the level set function. spacing (vector): A vector representing the spacing to set. SetDimension(dim) Set the dimension of the level set function. dim (int): An integer representing the dimension to set. SignedDistance(pos) Compute the signed distance at a given position. pos (vector): A vector representing the position to compute the signed distance. GradientInterpolate(pos) Compute the gradient at a given position using interpolation. pos (vector): A vector representing the position to compute the gradient. GradientMinus(pos) Compute the gradient at a given position using the minus side. pos (vector): A vector representing the position to compute the gradient. GradientPlus(pos) Compute the gradient at a given position using the plus side. pos (vector): A vector representing the position to compute the gradient. Reinitialization() Reinitialize the level set function. Reinitialization(iterations, cfl) Reinitialize the level set function with the given number of iterations and CFL coefficient. iterations (int): The number of iterations to perform. Default is 1. cfl (double): The CFL coefficient to use. Default is 0.5. STLReader This class is used for reading STL files. Constructor STLReader() Creates a new instance of the STLReader class. Methods ReadFile(filename) Reads an STL file and returns the vertices and triangles. filename (string): The name of the STL file to read. STLModel This class represents a 3D model loaded from an STL file. Constructor STLModel() Creates a new instance of the STLModel class. STLModel(vertices, facets) Creates a new instance of the STLModel class with the specified vertices and facets. vertices (list): A list of vertices in the model, where each vertex is a 3D vector. facets (list): A list of facets in the model, where each facet is a tuple of three vertex indices. Attributes vertices A list of vertices in the model, where each vertex is a 3D vector. facets A list of facets in the model, where each facet is a tuple of three vertex indices. Methods InitFromSTL(file_path) Loads an STL file and initializes the model from it. file_path (string): The path to the STL file. InitFromOFF(file_path) Loads an OFF file and initializes the model from it. file_path (string): The path to the OFF file. Translate(translation) Translates the model by the specified translation vector. translation (list): A 3D vector representing the translation. Rotate(rotation) Rotates the model by the specified rotation matrix. rotation (list): A 3x3 rotation matrix. CopyPose() Creates a copy of the model's current pose. CopyPoseDev() Creates a copy of the model's current pose on the device. SaveAsVTK(file_path) Saves the model as a VTK file. file_path (string): The path to the output VTK file. SaveAsSTL(file_path) Saves the model as an STL file. file_path (string): The path to the output STL file. RemoveUnreferencedVertices() Removes any vertices from the model that are not referenced by any facets. RemoveDuplicateVertices() Removes any duplicate vertices from the model. ReorientFacets() Reorients the facets in the model so that their normals point outward. Decimate(target_num_faces) Reduces the number of facets in the model using mesh decimation. target_num_faces (int): The desired number of facets in the decimated model. Standardize() Standardizes the model by centering it at the origin and scaling it to unit size. SetSize(size) Scales the model to the specified size. size (float): The desired size of the model. MakeConvex() Converts the model to a convex hull. SmoothMesh(smoothing_iterations) Smooths the mesh by averaging the position of each vertex with the positions of its neighbors. smoothing_iterations (int): The number of smoothing iterations to perform. MergeSTLModel(other_model) Merges the current model with another STLModel. other_model (STLModel): The model to merge with. GetTriangleStrips() Returns the model as a list of triangle strips. IsFaceOutside(facet_index, point) Checks whether a given point is outside the face with the specified index. facet_index (int): The index of the face to check. point (list): A 3D vector representing the point to check. IsConvex() Checks whether the model is convex. WSCVTSampler This class represents a sampler using the weighted stochastic collocation (WSC) method with the variable transformation technique (VTT). Constructor WSCVTSampler(max_iters=1000, tol=1e-6) Creates a new instance of the WSCVTSampler class. max_iters (int, optional): The maximum number of iterations for the optimization algorithm. Default is 1000. tol (float, optional): The tolerance for the optimization algorithm. Default is 1e-6. Attributes max_iters The maximum number of iterations for the optimization algorithm. tol The tolerance for the optimization algorithm. Methods GetInstance() Returns a singleton instance of the WSCVTSampler class. Get(num_samples, new_random=False) Generates a set of samples using the WSC method with VTT. num_samples (int): The number of samples to generate. new_random (bool, optional): If True, generate a new set of random numbers. Default is False. Voronoi This class represents a Voronoi object. Methods Solve(points, stl_model, bool_val) Computes Voronoi tessellation given a set of points and an STLModel. points (VecXT ): A vector of Vec3d points. stl_model (STLModel): An instance of the STLModel. bool_val (bool): A boolean value. Solve(stl_model, int_val1, int_val2, double_val, bool_val) Computes Voronoi tessellation given an STLModel, and specified parameters. stl_model (STLModel): An instance of the STLModel. int_val1 (int): An integer value. int_val2 (int): An integer value. double_val (double): A double value. bool_val (bool): A boolean value. SaveAsVTK() Saves the Voronoi tessellation as a VTK file. Cork This class provides methods for boolean operations on triangle meshes. Constructor Cork() Creates a new instance of the Cork class. Methods MeshIntersect(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None) Computes the intersection between two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided, a new vector will be created. MeshUnion(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None) Computes the union of two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided, a new vector will be created. MeshDifference(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None) Computes the difference between two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided OpenMP This module provides bindings for OpenMP , a specification for parallel programming in C++. Functions omp_get_max_threads() -> int Returns the maximum number of threads that can be used in parallel sections. omp_set_num_threads(num_threads: int) -> None Sets the number of threads to be used in parallel sections. num_threads (int) : The number of threads to be used. User manual \u250a Previous","title":"Ref utils"},{"location":"documentation/ref_utils/#_1","text":"User manual \u250a Previous","title":""},{"location":"documentation/ref_utils/#levelsetfunction","text":"This class represents a level set function.","title":"LevelSetFunction"},{"location":"documentation/ref_utils/#constructor","text":"","title":"Constructor"},{"location":"documentation/ref_utils/#levelsetfunction_1","text":"Creates a new instance of the LevelSetFunction class.","title":"LevelSetFunction()"},{"location":"documentation/ref_utils/#attributes","text":"","title":"Attributes"},{"location":"documentation/ref_utils/#corner","text":"A vector representing the corner of the level set function.","title":"corner"},{"location":"documentation/ref_utils/#spacing","text":"A vector representing the spacing of the level set function.","title":"spacing"},{"location":"documentation/ref_utils/#dim","text":"An integer representing the dimension of the level set function.","title":"dim"},{"location":"documentation/ref_utils/#methods","text":"","title":"Methods"},{"location":"documentation/ref_utils/#setcornercorner","text":"Set the corner of the level set function. corner (vector): A vector representing the corner to set.","title":"SetCorner(corner)"},{"location":"documentation/ref_utils/#setspacingspacing","text":"Set the spacing of the level set function. spacing (vector): A vector representing the spacing to set.","title":"SetSpacing(spacing)"},{"location":"documentation/ref_utils/#setdimensiondim","text":"Set the dimension of the level set function. dim (int): An integer representing the dimension to set.","title":"SetDimension(dim)"},{"location":"documentation/ref_utils/#signeddistancepos","text":"Compute the signed distance at a given position. pos (vector): A vector representing the position to compute the signed distance.","title":"SignedDistance(pos)"},{"location":"documentation/ref_utils/#gradientinterpolatepos","text":"Compute the gradient at a given position using interpolation. pos (vector): A vector representing the position to compute the gradient.","title":"GradientInterpolate(pos)"},{"location":"documentation/ref_utils/#gradientminuspos","text":"Compute the gradient at a given position using the minus side. pos (vector): A vector representing the position to compute the gradient.","title":"GradientMinus(pos)"},{"location":"documentation/ref_utils/#gradientpluspos","text":"Compute the gradient at a given position using the plus side. pos (vector): A vector representing the position to compute the gradient.","title":"GradientPlus(pos)"},{"location":"documentation/ref_utils/#reinitialization","text":"Reinitialize the level set function.","title":"Reinitialization()"},{"location":"documentation/ref_utils/#reinitializationiterations-cfl","text":"Reinitialize the level set function with the given number of iterations and CFL coefficient. iterations (int): The number of iterations to perform. Default is 1. cfl (double): The CFL coefficient to use. Default is 0.5.","title":"Reinitialization(iterations, cfl)"},{"location":"documentation/ref_utils/#stlreader","text":"This class is used for reading STL files.","title":"STLReader"},{"location":"documentation/ref_utils/#constructor_1","text":"","title":"Constructor"},{"location":"documentation/ref_utils/#stlreader_1","text":"Creates a new instance of the STLReader class.","title":"STLReader()"},{"location":"documentation/ref_utils/#methods_1","text":"","title":"Methods"},{"location":"documentation/ref_utils/#readfilefilename","text":"Reads an STL file and returns the vertices and triangles. filename (string): The name of the STL file to read.","title":"ReadFile(filename)"},{"location":"documentation/ref_utils/#stlmodel","text":"This class represents a 3D model loaded from an STL file.","title":"STLModel"},{"location":"documentation/ref_utils/#constructor_2","text":"","title":"Constructor"},{"location":"documentation/ref_utils/#stlmodel_1","text":"Creates a new instance of the STLModel class.","title":"STLModel()"},{"location":"documentation/ref_utils/#stlmodelvertices-facets","text":"Creates a new instance of the STLModel class with the specified vertices and facets. vertices (list): A list of vertices in the model, where each vertex is a 3D vector. facets (list): A list of facets in the model, where each facet is a tuple of three vertex indices.","title":"STLModel(vertices, facets)"},{"location":"documentation/ref_utils/#attributes_1","text":"","title":"Attributes"},{"location":"documentation/ref_utils/#vertices","text":"A list of vertices in the model, where each vertex is a 3D vector.","title":"vertices"},{"location":"documentation/ref_utils/#facets","text":"A list of facets in the model, where each facet is a tuple of three vertex indices.","title":"facets"},{"location":"documentation/ref_utils/#methods_2","text":"","title":"Methods"},{"location":"documentation/ref_utils/#initfromstlfile_path","text":"Loads an STL file and initializes the model from it. file_path (string): The path to the STL file.","title":"InitFromSTL(file_path)"},{"location":"documentation/ref_utils/#initfromofffile_path","text":"Loads an OFF file and initializes the model from it. file_path (string): The path to the OFF file.","title":"InitFromOFF(file_path)"},{"location":"documentation/ref_utils/#translatetranslation","text":"Translates the model by the specified translation vector. translation (list): A 3D vector representing the translation.","title":"Translate(translation)"},{"location":"documentation/ref_utils/#rotaterotation","text":"Rotates the model by the specified rotation matrix. rotation (list): A 3x3 rotation matrix.","title":"Rotate(rotation)"},{"location":"documentation/ref_utils/#copypose","text":"Creates a copy of the model's current pose.","title":"CopyPose()"},{"location":"documentation/ref_utils/#copyposedev","text":"Creates a copy of the model's current pose on the device.","title":"CopyPoseDev()"},{"location":"documentation/ref_utils/#saveasvtkfile_path","text":"Saves the model as a VTK file. file_path (string): The path to the output VTK file.","title":"SaveAsVTK(file_path)"},{"location":"documentation/ref_utils/#saveasstlfile_path","text":"Saves the model as an STL file. file_path (string): The path to the output STL file.","title":"SaveAsSTL(file_path)"},{"location":"documentation/ref_utils/#removeunreferencedvertices","text":"Removes any vertices from the model that are not referenced by any facets.","title":"RemoveUnreferencedVertices()"},{"location":"documentation/ref_utils/#removeduplicatevertices","text":"Removes any duplicate vertices from the model.","title":"RemoveDuplicateVertices()"},{"location":"documentation/ref_utils/#reorientfacets","text":"Reorients the facets in the model so that their normals point outward.","title":"ReorientFacets()"},{"location":"documentation/ref_utils/#decimatetarget_num_faces","text":"Reduces the number of facets in the model using mesh decimation. target_num_faces (int): The desired number of facets in the decimated model.","title":"Decimate(target_num_faces)"},{"location":"documentation/ref_utils/#standardize","text":"Standardizes the model by centering it at the origin and scaling it to unit size.","title":"Standardize()"},{"location":"documentation/ref_utils/#setsizesize","text":"Scales the model to the specified size. size (float): The desired size of the model.","title":"SetSize(size)"},{"location":"documentation/ref_utils/#makeconvex","text":"Converts the model to a convex hull.","title":"MakeConvex()"},{"location":"documentation/ref_utils/#smoothmeshsmoothing_iterations","text":"Smooths the mesh by averaging the position of each vertex with the positions of its neighbors. smoothing_iterations (int): The number of smoothing iterations to perform.","title":"SmoothMesh(smoothing_iterations)"},{"location":"documentation/ref_utils/#mergestlmodelother_model","text":"Merges the current model with another STLModel. other_model (STLModel): The model to merge with.","title":"MergeSTLModel(other_model)"},{"location":"documentation/ref_utils/#gettrianglestrips","text":"Returns the model as a list of triangle strips.","title":"GetTriangleStrips()"},{"location":"documentation/ref_utils/#isfaceoutsidefacet_index-point","text":"Checks whether a given point is outside the face with the specified index. facet_index (int): The index of the face to check. point (list): A 3D vector representing the point to check.","title":"IsFaceOutside(facet_index, point)"},{"location":"documentation/ref_utils/#isconvex","text":"Checks whether the model is convex.","title":"IsConvex()"},{"location":"documentation/ref_utils/#wscvtsampler","text":"This class represents a sampler using the weighted stochastic collocation (WSC) method with the variable transformation technique (VTT).","title":"WSCVTSampler"},{"location":"documentation/ref_utils/#constructor_3","text":"","title":"Constructor"},{"location":"documentation/ref_utils/#wscvtsamplermax_iters1000-tol1e-6","text":"Creates a new instance of the WSCVTSampler class. max_iters (int, optional): The maximum number of iterations for the optimization algorithm. Default is 1000. tol (float, optional): The tolerance for the optimization algorithm. Default is 1e-6.","title":"WSCVTSampler(max_iters=1000, tol=1e-6)"},{"location":"documentation/ref_utils/#attributes_2","text":"","title":"Attributes"},{"location":"documentation/ref_utils/#max_iters","text":"The maximum number of iterations for the optimization algorithm.","title":"max_iters"},{"location":"documentation/ref_utils/#tol","text":"The tolerance for the optimization algorithm. Methods","title":"tol"},{"location":"documentation/ref_utils/#getinstance","text":"Returns a singleton instance of the WSCVTSampler class.","title":"GetInstance()"},{"location":"documentation/ref_utils/#getnum_samples-new_randomfalse","text":"Generates a set of samples using the WSC method with VTT. num_samples (int): The number of samples to generate. new_random (bool, optional): If True, generate a new set of random numbers. Default is False.","title":"Get(num_samples, new_random=False)"},{"location":"documentation/ref_utils/#voronoi","text":"This class represents a Voronoi object.","title":"Voronoi"},{"location":"documentation/ref_utils/#methods_3","text":"","title":"Methods"},{"location":"documentation/ref_utils/#solvepoints-stl_model-bool_val","text":"Computes Voronoi tessellation given a set of points and an STLModel. points (VecXT ): A vector of Vec3d points. stl_model (STLModel): An instance of the STLModel. bool_val (bool): A boolean value.","title":"Solve(points, stl_model, bool_val)"},{"location":"documentation/ref_utils/#solvestl_model-int_val1-int_val2-double_val-bool_val","text":"Computes Voronoi tessellation given an STLModel, and specified parameters. stl_model (STLModel): An instance of the STLModel. int_val1 (int): An integer value. int_val2 (int): An integer value. double_val (double): A double value. bool_val (bool): A boolean value.","title":"Solve(stl_model, int_val1, int_val2, double_val, bool_val)"},{"location":"documentation/ref_utils/#saveasvtk","text":"Saves the Voronoi tessellation as a VTK file.","title":"SaveAsVTK()"},{"location":"documentation/ref_utils/#cork","text":"This class provides methods for boolean operations on triangle meshes.","title":"Cork"},{"location":"documentation/ref_utils/#constructor_4","text":"","title":"Constructor"},{"location":"documentation/ref_utils/#cork_1","text":"Creates a new instance of the Cork class.","title":"Cork()"},{"location":"documentation/ref_utils/#methods_4","text":"","title":"Methods"},{"location":"documentation/ref_utils/#meshintersectvertices1-triangles1-vertices2-triangles2-vertices_outnone-triangles_outnone-labels_outnone","text":"Computes the intersection between two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided, a new vector will be created.","title":"MeshIntersect(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None)"},{"location":"documentation/ref_utils/#meshunionvertices1-triangles1-vertices2-triangles2-vertices_outnone-triangles_outnone-labels_outnone","text":"Computes the union of two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided, a new vector will be created.","title":"MeshUnion(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None)"},{"location":"documentation/ref_utils/#meshdifferencevertices1-triangles1-vertices2-triangles2-vertices_outnone-triangles_outnone-labels_outnone","text":"Computes the difference between two triangle meshes. vertices1 (VecXT ): A vector of vertices defining the first mesh. triangles1 (VecXT ): A vector of triangles defining the first mesh. vertices2 (VecXT ): A vector of vertices defining the second mesh. triangles2 (VecXT ): A vector of triangles defining the second mesh. vertices_out (VecXT , optional): A vector to store the output vertices. If not provided, a new vector will be created. triangles_out (VecXT , optional): A vector to store the output triangles. If not provided, a new vector will be created. labels_out (VecXT , optional): A vector to store the output labels. If not provided","title":"MeshDifference(vertices1, triangles1, vertices2, triangles2, vertices_out=None, triangles_out=None, labels_out=None)"},{"location":"documentation/ref_utils/#openmp","text":"This module provides bindings for OpenMP , a specification for parallel programming in C++.","title":"OpenMP"},{"location":"documentation/ref_utils/#functions","text":"omp_get_max_threads() -> int Returns the maximum number of threads that can be used in parallel sections. omp_set_num_threads(num_threads: int) -> None Sets the number of threads to be used in parallel sections. num_threads (int) : The number of threads to be used. User manual \u250a Previous","title":"Functions"},{"location":"documentation/user_manual/","text":"User manual Installation : installation, test, and dependencies, etc. Basic usage : running simulation, particle shape reconstruction, post-processing, etc. Paraview rendering : hints and procedures in paraview visualization. Blender rendering : hints and procedures in blender visualization. CFD-DEM simulation : coupled CFD-DEM simulation using OpenFOAM NetDEM. Python API reference dem : defines the basic classes for dem calculations, including contact model, contact solver, etc. domain :defines classes for domain management, including CellManager, Domain, DomainManager, etc. fem : for FEM calculations, including TetMesh and Membrane, etc. modifier : defines the classes for modify DEM calculations, such as adding gravity, dumping simulation data, prescribing particle velocities, etc. mpi : for exchanging particle information through MPI parallel computing. netdem : defines all the basic classes for NetDEM modelling, including utils, fem, dem, domain, peridigm, shape, scene, modifier, mpi, simulation, etc. peridigm : interface to couple with peridigm for modeling particle breakage. scene : defines the basic classes for DEM units, including Scene, Particle, Wall, ContactPP, etc. shape : defines a variety of shapes, including Sphere, Ellipsoid, TriMesh, etc. simulation : a class for handling all the resources of a DEM simulation, incluidng domain_manager, mpi_manager, modifier_manager, scene, dem_solver, mech_time, mech_cycles, enable_logging, etc. utils : other ultility classes and functions, including Math, STLReader, STLModel, etc.","title":"User manual"},{"location":"documentation/user_manual/#_1","text":"","title":""},{"location":"documentation/user_manual/#user-manual","text":"Installation : installation, test, and dependencies, etc. Basic usage : running simulation, particle shape reconstruction, post-processing, etc. Paraview rendering : hints and procedures in paraview visualization. Blender rendering : hints and procedures in blender visualization. CFD-DEM simulation : coupled CFD-DEM simulation using OpenFOAM NetDEM.","title":"User manual"},{"location":"documentation/user_manual/#python-api-reference","text":"dem : defines the basic classes for dem calculations, including contact model, contact solver, etc. domain :defines classes for domain management, including CellManager, Domain, DomainManager, etc. fem : for FEM calculations, including TetMesh and Membrane, etc. modifier : defines the classes for modify DEM calculations, such as adding gravity, dumping simulation data, prescribing particle velocities, etc. mpi : for exchanging particle information through MPI parallel computing. netdem : defines all the basic classes for NetDEM modelling, including utils, fem, dem, domain, peridigm, shape, scene, modifier, mpi, simulation, etc. peridigm : interface to couple with peridigm for modeling particle breakage. scene : defines the basic classes for DEM units, including Scene, Particle, Wall, ContactPP, etc. shape : defines a variety of shapes, including Sphere, Ellipsoid, TriMesh, etc. simulation : a class for handling all the resources of a DEM simulation, incluidng domain_manager, mpi_manager, modifier_manager, scene, dem_solver, mech_time, mech_cycles, enable_logging, etc. utils : other ultility classes and functions, including Math, STLReader, STLModel, etc.","title":"Python API reference"},{"location":"download/","text":"NetDEM Source code: https://github.com/apaam/netdem Website: https://github.com/apaam/netdem_docs Post-processing scripts Matlab: https://github.com/apaam/postprocess_scripts Other relevant softwares Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Download"},{"location":"download/#_1","text":"","title":""},{"location":"download/#netdem","text":"Source code: https://github.com/apaam/netdem Website: https://github.com/apaam/netdem_docs","title":"NetDEM"},{"location":"download/#post-processing-scripts","text":"Matlab: https://github.com/apaam/postprocess_scripts","title":"Post-processing scripts"},{"location":"download/#other-relevant-softwares","text":"Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Other relevant softwares"},{"location":"examples/","text":"General examples Random packing : random packing of particles using rain-falling appraoch. Blade mixing : particles in a blade mixer. Geotechnical experiments","title":"Examples"},{"location":"examples/#_1","text":"","title":""},{"location":"examples/#general-examples","text":"Random packing : random packing of particles using rain-falling appraoch. Blade mixing : particles in a blade mixer.","title":"General examples"},{"location":"examples/#geotechnical-experiments","text":"","title":"Geotechnical experiments"},{"location":"examples/angle_of_repose/","text":"Under construction.","title":"Angle of repose"},{"location":"examples/blade_mixing/","text":"Example \u250a Previous \u250a Next Blade mixing Whole script The code is a C++ implementation of a simulation using the netdem library. It sets up a simulation environment, including the simulation domain, contact model, shapes, walls, gravity, data dumping, and runs the simulation. #include \"data_dumper.hpp\" #include \"gen_pack.hpp\" #include \"gen_wall_box_plane.hpp\" #include \"gravity.hpp\" #include \"model_linear_spring.hpp\" #include \"shape_cylinder.hpp\" #include \"shape_sphere.hpp\" #include \"shape_triangle.hpp\" #include \"simulation.hpp\" #include <iostream> #include <unordered_map> using namespace netdem; using namespace std; void ImportWall(Simulation *sim) { STLModel cylinder_stl; cylinder_stl.InitFromSTL(\"data/cylinder.stl\"); for (auto &vert : cylinder_stl.vertices) { vert[2] *= 0.5; } cylinder_stl.SaveAsSTL(\"tmp/tests/cylinder_outer.stl\"); for (auto &facet : cylinder_stl.facets) { Triangle triangle(cylinder_stl.vertices[facet[0]], cylinder_stl.vertices[facet[1]], cylinder_stl.vertices[facet[2]]); auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall(shape_ptr); sim->scene.InsertWall(wall); } for (auto &vert : cylinder_stl.vertices) { vert[0] *= 0.15; vert[1] *= 0.15; vert[2] *= 0.64; vert[2] -= 0.10; } cylinder_stl.SaveAsSTL(\"tmp/tests/cylinder_inner.stl\"); for (auto &facet : cylinder_stl.facets) { Triangle triangle(cylinder_stl.vertices[facet[0]], cylinder_stl.vertices[facet[1]], cylinder_stl.vertices[facet[2]]); auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall(shape_ptr); sim->scene.InsertWall(wall); } STLModel propeller_stl; propeller_stl.InitFromSTL(\"data/copyleft/propeller.stl\"); propeller_stl.Standardize(); for (auto &vert : propeller_stl.vertices) { vert[0] *= 0.14; vert[1] *= 0.14; vert[2] *= 0.8; vert[2] -= 0.075; } propeller_stl.SaveAsSTL(\"tmp/tests/propeller.stl\"); for (auto &facet : propeller_stl.facets) { Triangle triangle(propeller_stl.vertices[facet[0]], propeller_stl.vertices[facet[1]], propeller_stl.vertices[facet[2]]); triangle.skin *= 10.0; auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall; wall.SetShape(shape_ptr, true); wall.SetVelocitySpin(0, 0, -2.0 * Math::PI); sim->scene.InsertWall(wall); } } int main(int argc, char **argv) { Simulation *sim = new Simulation(); sim->domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6); sim->domain_manager.SetCellSpacing(0.2, 0.2, 0.2); LinearSpring cnt_model = LinearSpring(1.0e4, 1.0e4, 0.7, 0.5); sim->scene.InsertContactModel(&cnt_model); sim->scene.SetNumberOfMaterials(1); sim->scene.SetCollisionModel(0, 0, cnt_model.label); Sphere sphere = Sphere(0.02); sphere.skin *= 1.0; auto shape_ptr = sim->scene.InsertShape(&sphere); VecXT<Particle> particle_list = PackGenerator::GetGridPack( 0.7, 0.7, 0.1, 0, 0, 0.2, 25, 20, 2, sim->scene.GetShapes()); for (auto &p : particle_list) { p.SetVelocity(0, 0, -2.0); } ImportWall(sim); Gravity grav; grav.Init(sim); sim->modifier_manager.Insert(&grav); sim->modifier_manager.Enable(grav.label); DataDumper data_dumper; data_dumper.Init(sim); data_dumper.SetRootPath(\"tmp/out/\"); data_dumper.SetSaveByCycles(100); data_dumper.dump_wall_info = true; data_dumper.dump_shape_info = true; sim->modifier_manager.Insert(&data_dumper); sim->modifier_manager.Enable(data_dumper.label); for (int i = 0; i < 20; i++) { sim->scene.InsertParticle(particle_list); sim->Run(0.1); } sim->Run(2.0); delete sim; } Step-by-step explaination Here's a breakdown of the code: void ImportWall(Simulation *sim) { // ... } This function defines the ImportWall function, which is used to import wall shapes into the simulation. The walls are created based on STL models and inserted into the simulation scene. int main(int argc, char **argv) { Simulation *sim = new Simulation(); The main function initializes a new Simulation object and assigns it to the sim pointer. sim->domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6); sim->domain_manager.SetCellSpacing(0.2, 0.2, 0.2); The boundary and cell spacing of the simulation domain are set using the methods SetBound and SetCellSpacing of the domain_manager object. LinearSpring cnt_model = LinearSpring(1.0e4, 1.0e4, 0.7, 0.5); sim->scene.InsertContactModel(&cnt_model); sim->scene.SetNumberOfMaterials(1); sim->scene.SetCollisionModel(0, 0, cnt_model.label); A linear spring contact model is created and inserted into the simulation scene using the InsertContactModel method of the scene object. The number of materials in the scene is set to 1, and the collision model at index 0 is updated with the label of the contact model. Sphere sphere = Sphere(0.02); sphere.skin *= 1.0; auto shape_ptr = sim->scene.InsertShape(&sphere); A sphere shape is created and inserted into the simulation scene using the InsertShape method of the scene object. The sphere's skin (radius) is adjusted, and the resulting shape pointer is stored for later use. VecXT<Particle> particle_list = PackGenerator::GetGridPack( 0.7, 0.7, 0.1, 0, 0, 0.2, 25, 20, 2, sim->scene.GetShapes()); for (auto &p : particle_list) { p.SetVelocity(0, 0, -2.0); } A grid-based particle pack is generated using the GetGridPack method of the PackGenerator class. The parameters provided determine the position, size, and layout of the particles in the grid. The initial velocity of each particle in the pack is set to move downward. ImportWall(sim); The ImportWall function is called to import wall shapes into the simulation. Gravity grav; grav.Init(sim); sim->modifier_manager.Insert(&grav); sim->modifier_manager.Enable(grav.label); A gravity modifier is created, initialized with the simulation object, inserted into the modifier manager, and enabled. DataDumper data_dumper; data_dumper.Init(sim); data_dumper.SetRootPath(\"tmp/out/\"); data_dumper.SetSaveByCycles(100); data_dumper.dump_wall_info = true; data_dumper.dump_shape_info = true; sim->modifier_manager.Insert(&data_dumper); sim->modifier_manager.Enable(data_dumper.label); A data dumper object is created, initialized with the simulation object, and configured to save data by cycles. The root path for saving files is set, and options for dumping wall and shape information are enabled. The data dumper object is then inserted into the modifier manager and enabled. for (int i = 0; i < 20; i++) { sim->scene.InsertParticle(particle_list); sim->Run(0.1); } sim->Run(2.0); delete sim; } A loop is used to insert particles from the particle list into the simulation scene, and the simulation is run for a duration of 0.1 time units. This loop allows the particles to settle in the simulation before further simulation steps. After the loop, the simulation is run for an additional 2.0 time units. Finally, the sim pointer is deleted to free the memory. Simulation result Example \u250a Previous \u250a Next","title":"Blade mixing"},{"location":"examples/blade_mixing/#_1","text":"Example \u250a Previous \u250a Next","title":""},{"location":"examples/blade_mixing/#blade-mixing","text":"","title":"Blade mixing"},{"location":"examples/blade_mixing/#whole-script","text":"The code is a C++ implementation of a simulation using the netdem library. It sets up a simulation environment, including the simulation domain, contact model, shapes, walls, gravity, data dumping, and runs the simulation. #include \"data_dumper.hpp\" #include \"gen_pack.hpp\" #include \"gen_wall_box_plane.hpp\" #include \"gravity.hpp\" #include \"model_linear_spring.hpp\" #include \"shape_cylinder.hpp\" #include \"shape_sphere.hpp\" #include \"shape_triangle.hpp\" #include \"simulation.hpp\" #include <iostream> #include <unordered_map> using namespace netdem; using namespace std; void ImportWall(Simulation *sim) { STLModel cylinder_stl; cylinder_stl.InitFromSTL(\"data/cylinder.stl\"); for (auto &vert : cylinder_stl.vertices) { vert[2] *= 0.5; } cylinder_stl.SaveAsSTL(\"tmp/tests/cylinder_outer.stl\"); for (auto &facet : cylinder_stl.facets) { Triangle triangle(cylinder_stl.vertices[facet[0]], cylinder_stl.vertices[facet[1]], cylinder_stl.vertices[facet[2]]); auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall(shape_ptr); sim->scene.InsertWall(wall); } for (auto &vert : cylinder_stl.vertices) { vert[0] *= 0.15; vert[1] *= 0.15; vert[2] *= 0.64; vert[2] -= 0.10; } cylinder_stl.SaveAsSTL(\"tmp/tests/cylinder_inner.stl\"); for (auto &facet : cylinder_stl.facets) { Triangle triangle(cylinder_stl.vertices[facet[0]], cylinder_stl.vertices[facet[1]], cylinder_stl.vertices[facet[2]]); auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall(shape_ptr); sim->scene.InsertWall(wall); } STLModel propeller_stl; propeller_stl.InitFromSTL(\"data/copyleft/propeller.stl\"); propeller_stl.Standardize(); for (auto &vert : propeller_stl.vertices) { vert[0] *= 0.14; vert[1] *= 0.14; vert[2] *= 0.8; vert[2] -= 0.075; } propeller_stl.SaveAsSTL(\"tmp/tests/propeller.stl\"); for (auto &facet : propeller_stl.facets) { Triangle triangle(propeller_stl.vertices[facet[0]], propeller_stl.vertices[facet[1]], propeller_stl.vertices[facet[2]]); triangle.skin *= 10.0; auto shape_ptr = sim->scene.InsertShape(&triangle); Wall wall; wall.SetShape(shape_ptr, true); wall.SetVelocitySpin(0, 0, -2.0 * Math::PI); sim->scene.InsertWall(wall); } } int main(int argc, char **argv) { Simulation *sim = new Simulation(); sim->domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6); sim->domain_manager.SetCellSpacing(0.2, 0.2, 0.2); LinearSpring cnt_model = LinearSpring(1.0e4, 1.0e4, 0.7, 0.5); sim->scene.InsertContactModel(&cnt_model); sim->scene.SetNumberOfMaterials(1); sim->scene.SetCollisionModel(0, 0, cnt_model.label); Sphere sphere = Sphere(0.02); sphere.skin *= 1.0; auto shape_ptr = sim->scene.InsertShape(&sphere); VecXT<Particle> particle_list = PackGenerator::GetGridPack( 0.7, 0.7, 0.1, 0, 0, 0.2, 25, 20, 2, sim->scene.GetShapes()); for (auto &p : particle_list) { p.SetVelocity(0, 0, -2.0); } ImportWall(sim); Gravity grav; grav.Init(sim); sim->modifier_manager.Insert(&grav); sim->modifier_manager.Enable(grav.label); DataDumper data_dumper; data_dumper.Init(sim); data_dumper.SetRootPath(\"tmp/out/\"); data_dumper.SetSaveByCycles(100); data_dumper.dump_wall_info = true; data_dumper.dump_shape_info = true; sim->modifier_manager.Insert(&data_dumper); sim->modifier_manager.Enable(data_dumper.label); for (int i = 0; i < 20; i++) { sim->scene.InsertParticle(particle_list); sim->Run(0.1); } sim->Run(2.0); delete sim; }","title":"Whole script"},{"location":"examples/blade_mixing/#step-by-step-explaination","text":"Here's a breakdown of the code: void ImportWall(Simulation *sim) { // ... } This function defines the ImportWall function, which is used to import wall shapes into the simulation. The walls are created based on STL models and inserted into the simulation scene. int main(int argc, char **argv) { Simulation *sim = new Simulation(); The main function initializes a new Simulation object and assigns it to the sim pointer. sim->domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6); sim->domain_manager.SetCellSpacing(0.2, 0.2, 0.2); The boundary and cell spacing of the simulation domain are set using the methods SetBound and SetCellSpacing of the domain_manager object. LinearSpring cnt_model = LinearSpring(1.0e4, 1.0e4, 0.7, 0.5); sim->scene.InsertContactModel(&cnt_model); sim->scene.SetNumberOfMaterials(1); sim->scene.SetCollisionModel(0, 0, cnt_model.label); A linear spring contact model is created and inserted into the simulation scene using the InsertContactModel method of the scene object. The number of materials in the scene is set to 1, and the collision model at index 0 is updated with the label of the contact model. Sphere sphere = Sphere(0.02); sphere.skin *= 1.0; auto shape_ptr = sim->scene.InsertShape(&sphere); A sphere shape is created and inserted into the simulation scene using the InsertShape method of the scene object. The sphere's skin (radius) is adjusted, and the resulting shape pointer is stored for later use. VecXT<Particle> particle_list = PackGenerator::GetGridPack( 0.7, 0.7, 0.1, 0, 0, 0.2, 25, 20, 2, sim->scene.GetShapes()); for (auto &p : particle_list) { p.SetVelocity(0, 0, -2.0); } A grid-based particle pack is generated using the GetGridPack method of the PackGenerator class. The parameters provided determine the position, size, and layout of the particles in the grid. The initial velocity of each particle in the pack is set to move downward. ImportWall(sim); The ImportWall function is called to import wall shapes into the simulation. Gravity grav; grav.Init(sim); sim->modifier_manager.Insert(&grav); sim->modifier_manager.Enable(grav.label); A gravity modifier is created, initialized with the simulation object, inserted into the modifier manager, and enabled. DataDumper data_dumper; data_dumper.Init(sim); data_dumper.SetRootPath(\"tmp/out/\"); data_dumper.SetSaveByCycles(100); data_dumper.dump_wall_info = true; data_dumper.dump_shape_info = true; sim->modifier_manager.Insert(&data_dumper); sim->modifier_manager.Enable(data_dumper.label); A data dumper object is created, initialized with the simulation object, and configured to save data by cycles. The root path for saving files is set, and options for dumping wall and shape information are enabled. The data dumper object is then inserted into the modifier manager and enabled. for (int i = 0; i < 20; i++) { sim->scene.InsertParticle(particle_list); sim->Run(0.1); } sim->Run(2.0); delete sim; } A loop is used to insert particles from the particle list into the simulation scene, and the simulation is run for a duration of 0.1 time units. This loop allows the particles to settle in the simulation before further simulation steps. After the loop, the simulation is run for an additional 2.0 time units. Finally, the sim pointer is deleted to free the memory.","title":"Step-by-step explaination"},{"location":"examples/blade_mixing/#simulation-result","text":"Example \u250a Previous \u250a Next","title":"Simulation result"},{"location":"examples/granular_mixing/","text":"Under construction.","title":"Granular mixing"},{"location":"examples/random_packing/","text":"Example \u250a Previous \u250a Next Random packing Whole script The script is written in Python and utilizes the netdem library to perform a simulation. It sets up a simulation environment with a defined boundary, contact models, triangular meshes, particle packs, walls, gravity, data dumping, and runs the simulation. It is important to note that the script assumes the required netdem library is properly installed and accessible in the Python environment. import netdem sim = netdem.Simulation() sim.domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6) sim.domain_manager.SetCellSpacing(0.3, 0.3, 0.3) cnt_model = netdem.LinearSpring(2.0e6, 1.0e6, 0.7, 0.5) cnt_model_prt = sim.scene.InsertContactModel(cnt_model) sim.scene.SetNumberOfMaterials(1) sim.scene.SetCollisionModel(0, 0, cnt_model_prt) tri_mesh = netdem.TriMesh() tri_mesh.InitFromSTL(\"data/particle_template.stl\") tri_mesh.Decimate(400) tri_mesh.MakeConvex() tri_mesh.AlignAxes() tri_mesh.SetSize(0.1) tri_mesh_ptr = sim.scene.InsertShape(tri_mesh) pack_generator = netdem.PackGenerator() particle_list = pack_generator.GetGridPack(1, 1, 0.2, 0, 0, 0.4, 5, 5, 1, tri_mesh_ptr) for p in particle_list: p.SetVelocity(0, 0, -2.0) wall_box = netdem.WallBoxPlane(1, 1, 1, 0, 0, 0) wall_box.ImportToScene(sim.scene) grav = netdem.Gravity() grav.Init(sim) sim.modifier_manager.Insert(grav) sim.modifier_manager.Enable(grav.label) data_dumper = netdem.DataDumper() data_dumper.Init(sim) data_dumper.SetRootPath(\"tmp/out/\") data_dumper.SetSaveByCycles(100) data_dumper.dump_contact_info = True data_dumper.dump_wall_info = True data_dumper.SaveShapeInfoAsSTL() sim.modifier_manager.Insert(data_dumper) sim.modifier_manager.Enable(data_dumper.label) for i in range(20): sim.scene.InsertParticle(particle_list) sim.Run(0.1) sim.Run(2.0) Step-by-step explaination Below is a detailed documentation of the script, explaining each line and its purpose. import netdem This line imports the netdem module, which contains classes and functions necessary for the simulation. sim = netdem.Simulation() Creates an instance of the Simulation class and assigns it to the variable sim . This object will be used to manage the simulation. sim.domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6) Sets the boundary of the simulation domain using the SetBound method of the domain_manager object. The specified coordinates (-0.6, -0.6, -0.6) and (0.6, 0.6, 0.6) define the minimum and maximum bounds of the simulation domain in three dimensions. sim.domain_manager.SetCellSpacing(0.3, 0.3, 0.3) Sets the cell spacing of the simulation domain using the SetCellSpacing method of the domain_manager object. The specified values (0.3, 0.3, 0.3) determine the size of each cell in the simulation domain grid. cnt_model = netdem.LinearSpring(2.0e6, 1.0e6, 0.7, 0.5) Creates an instance of the LinearSpring class from the netdem module and assigns it to the variable cnt_model . This model represents a linear spring with specified parameters: stiffness, damping, restitution, and friction. cnt_model_prt = sim.scene.InsertContactModel(cnt_model) Inserts the contact model ( cnt_model ) into the simulation scene using the InsertContactModel method of the scene object. The resulting contact model is assigned to the variable cnt_model_prt for later use. sim.scene.SetNumberOfMaterials(1) sim.scene.SetCollisionModel(0, 0, cnt_model_prt) Sets the number of materials in the simulation scene to 1 and assigns the contact model ( cnt_model_prt ) to the collision model at index 0. These operations are performed using methods from the scene object. tri_mesh = netdem.TriMesh() Creates an instance of the TriMesh class from the netdem module and assigns it to the variable tri_mesh . This object represents a triangular mesh. tri_mesh.InitFromSTL(\"data/particle_template.stl\") Initializes the tri_mesh object by loading a triangular mesh from an STL file located at \"data/particle_template.stl\". The provided STL file is used as a template for particles in the simulation. tri_mesh.Decimate(400) Decimates the loaded triangular mesh, reducing the number of polygons while preserving the overall shape. The size of the decimation is determined by the parameter 400. tri_mesh.MakeConvex() Converts the triangular mesh into a convex hull representation using the MakeConvex method. This step simplifies the geometry and improves simulation performance. tri_mesh.AlignAxes() Aligns the axes of the triangular mesh using the AlignAxes method. This step ensures that the mesh aligns properly with the simulation coordinate system. tri_mesh.SetSize(0.1) Sets the size of the triangular mesh using the SetSize method. The specified value (0.1) determines the new size of the mesh. tri_mesh_ptr = sim.scene.InsertShape(tri_mesh) Inserts the triangular mesh object into the simulation scene using the InsertShape method of the scene object. The resulting shape is assigned to the variable tri_mesh_ptr for later use. pack_generator = netdem.PackGenerator() Creates an instance of the PackGenerator class and assigns it to the variable pack_generator . This object is responsible for generating particle packs in the simulation. particle_list = pack_generator.GetGridPack(1, 1, 0.2, 0, 0, 0.4, 5, 5, 1, tri_mesh_ptr) Generates a grid-based particle pack using the GetGridPack method of the pack_generator object. The generated particles are assigned to the particle_list variable. The parameters provided determine the number of particles in each dimension of the grid (1 particle in the x-direction, 1 particle in the y-direction), the spacing between particles (0.2), the position of the origin of the grid (0, 0, 0.4), the number of particles in each dimension (5 particles in the x-direction, 5 particles in the y-direction), the height of the particle pack (1), and the shape pointer ( tri_mesh_ptr ) used as a template for the particles. for p in particle_list: p.SetVelocity(0, 0, -2.0) Sets the initial velocity of each particle in the particle_list to (0, 0, -2.0) using the SetVelocity method. This sets a downward velocity for the particles. wall_box = netdem.WallBoxPlane(1, 1, 1, 0, 0, 0) wall_box.ImportToScene(sim.scene) Creates an instance of the WallBoxPlane class with specified dimensions (1, 1, 1) and position (0, 0, 0). Then, it imports the wall box object into the simulation scene using the ImportToScene method of the wall_box object. This creates a box-shaped wall in the simulation. grav = netdem.Gravity() grav.Init(sim) sim.modifier_manager.Insert(grav) sim.modifier_manager.Enable(grav.label) Creates an instance of the Gravity class and assigns it to the variable grav . The Init method initializes the gravity object using the sim simulation object. The gravity object is then inserted into the modifier manager of the simulation and enabled. This ensures that gravity affects the particles in the simulation. data_dumper = netdem.DataDumper() data_dumper.Init(sim) data_dumper.SetRootPath(\"tmp/out/\") data_dumper.SetSaveByCycles(100) data_dumper.dump_contact_info = True data_dumper.dump_wall_info = True data_dumper.SaveShapeInfoAsSTL() sim.modifier_manager.Insert(data_dumper) sim.modifier_manager.Enable(data_dumper.label) Creates an instance of the DataDumper class and assigns it to the variable data_dumper . The Init method initializes the data dumper object using the sim simulation object. The following lines specify various settings for the data dumper, such as the root path for saving files (\"tmp/out/\"), the save frequency (every 100 cycles), and the types of data to be dumped (contact information and wall information). Additionally, the SaveShapeInfoAsSTL method is called to enable saving shape information as STL files. Finally, the data dumper object is inserted into the modifier manager of the simulation and enabled. for i in range(20): sim.scene.InsertParticle(particle_list) sim.Run(0.1) In a loop that iterates 20 times, particles from the particle_list are inserted into the simulation scene using the InsertParticle method. Then, the simulation is run for a duration of 0.1 time units using the Run method. This loop allows the particles to settle in the simulation before further simulation steps. sim.Run(2.0) Finally, the simulation is run for a duration of 2.0 time units using the Run method. This completes the simulation process. Simulation result Example \u250a Previous \u250a Next","title":"Random packing"},{"location":"examples/random_packing/#_1","text":"Example \u250a Previous \u250a Next","title":""},{"location":"examples/random_packing/#random-packing","text":"","title":"Random packing"},{"location":"examples/random_packing/#whole-script","text":"The script is written in Python and utilizes the netdem library to perform a simulation. It sets up a simulation environment with a defined boundary, contact models, triangular meshes, particle packs, walls, gravity, data dumping, and runs the simulation. It is important to note that the script assumes the required netdem library is properly installed and accessible in the Python environment. import netdem sim = netdem.Simulation() sim.domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6) sim.domain_manager.SetCellSpacing(0.3, 0.3, 0.3) cnt_model = netdem.LinearSpring(2.0e6, 1.0e6, 0.7, 0.5) cnt_model_prt = sim.scene.InsertContactModel(cnt_model) sim.scene.SetNumberOfMaterials(1) sim.scene.SetCollisionModel(0, 0, cnt_model_prt) tri_mesh = netdem.TriMesh() tri_mesh.InitFromSTL(\"data/particle_template.stl\") tri_mesh.Decimate(400) tri_mesh.MakeConvex() tri_mesh.AlignAxes() tri_mesh.SetSize(0.1) tri_mesh_ptr = sim.scene.InsertShape(tri_mesh) pack_generator = netdem.PackGenerator() particle_list = pack_generator.GetGridPack(1, 1, 0.2, 0, 0, 0.4, 5, 5, 1, tri_mesh_ptr) for p in particle_list: p.SetVelocity(0, 0, -2.0) wall_box = netdem.WallBoxPlane(1, 1, 1, 0, 0, 0) wall_box.ImportToScene(sim.scene) grav = netdem.Gravity() grav.Init(sim) sim.modifier_manager.Insert(grav) sim.modifier_manager.Enable(grav.label) data_dumper = netdem.DataDumper() data_dumper.Init(sim) data_dumper.SetRootPath(\"tmp/out/\") data_dumper.SetSaveByCycles(100) data_dumper.dump_contact_info = True data_dumper.dump_wall_info = True data_dumper.SaveShapeInfoAsSTL() sim.modifier_manager.Insert(data_dumper) sim.modifier_manager.Enable(data_dumper.label) for i in range(20): sim.scene.InsertParticle(particle_list) sim.Run(0.1) sim.Run(2.0)","title":"Whole script"},{"location":"examples/random_packing/#step-by-step-explaination","text":"Below is a detailed documentation of the script, explaining each line and its purpose. import netdem This line imports the netdem module, which contains classes and functions necessary for the simulation. sim = netdem.Simulation() Creates an instance of the Simulation class and assigns it to the variable sim . This object will be used to manage the simulation. sim.domain_manager.SetBound(-0.6, -0.6, -0.6, 0.6, 0.6, 0.6) Sets the boundary of the simulation domain using the SetBound method of the domain_manager object. The specified coordinates (-0.6, -0.6, -0.6) and (0.6, 0.6, 0.6) define the minimum and maximum bounds of the simulation domain in three dimensions. sim.domain_manager.SetCellSpacing(0.3, 0.3, 0.3) Sets the cell spacing of the simulation domain using the SetCellSpacing method of the domain_manager object. The specified values (0.3, 0.3, 0.3) determine the size of each cell in the simulation domain grid. cnt_model = netdem.LinearSpring(2.0e6, 1.0e6, 0.7, 0.5) Creates an instance of the LinearSpring class from the netdem module and assigns it to the variable cnt_model . This model represents a linear spring with specified parameters: stiffness, damping, restitution, and friction. cnt_model_prt = sim.scene.InsertContactModel(cnt_model) Inserts the contact model ( cnt_model ) into the simulation scene using the InsertContactModel method of the scene object. The resulting contact model is assigned to the variable cnt_model_prt for later use. sim.scene.SetNumberOfMaterials(1) sim.scene.SetCollisionModel(0, 0, cnt_model_prt) Sets the number of materials in the simulation scene to 1 and assigns the contact model ( cnt_model_prt ) to the collision model at index 0. These operations are performed using methods from the scene object. tri_mesh = netdem.TriMesh() Creates an instance of the TriMesh class from the netdem module and assigns it to the variable tri_mesh . This object represents a triangular mesh. tri_mesh.InitFromSTL(\"data/particle_template.stl\") Initializes the tri_mesh object by loading a triangular mesh from an STL file located at \"data/particle_template.stl\". The provided STL file is used as a template for particles in the simulation. tri_mesh.Decimate(400) Decimates the loaded triangular mesh, reducing the number of polygons while preserving the overall shape. The size of the decimation is determined by the parameter 400. tri_mesh.MakeConvex() Converts the triangular mesh into a convex hull representation using the MakeConvex method. This step simplifies the geometry and improves simulation performance. tri_mesh.AlignAxes() Aligns the axes of the triangular mesh using the AlignAxes method. This step ensures that the mesh aligns properly with the simulation coordinate system. tri_mesh.SetSize(0.1) Sets the size of the triangular mesh using the SetSize method. The specified value (0.1) determines the new size of the mesh. tri_mesh_ptr = sim.scene.InsertShape(tri_mesh) Inserts the triangular mesh object into the simulation scene using the InsertShape method of the scene object. The resulting shape is assigned to the variable tri_mesh_ptr for later use. pack_generator = netdem.PackGenerator() Creates an instance of the PackGenerator class and assigns it to the variable pack_generator . This object is responsible for generating particle packs in the simulation. particle_list = pack_generator.GetGridPack(1, 1, 0.2, 0, 0, 0.4, 5, 5, 1, tri_mesh_ptr) Generates a grid-based particle pack using the GetGridPack method of the pack_generator object. The generated particles are assigned to the particle_list variable. The parameters provided determine the number of particles in each dimension of the grid (1 particle in the x-direction, 1 particle in the y-direction), the spacing between particles (0.2), the position of the origin of the grid (0, 0, 0.4), the number of particles in each dimension (5 particles in the x-direction, 5 particles in the y-direction), the height of the particle pack (1), and the shape pointer ( tri_mesh_ptr ) used as a template for the particles. for p in particle_list: p.SetVelocity(0, 0, -2.0) Sets the initial velocity of each particle in the particle_list to (0, 0, -2.0) using the SetVelocity method. This sets a downward velocity for the particles. wall_box = netdem.WallBoxPlane(1, 1, 1, 0, 0, 0) wall_box.ImportToScene(sim.scene) Creates an instance of the WallBoxPlane class with specified dimensions (1, 1, 1) and position (0, 0, 0). Then, it imports the wall box object into the simulation scene using the ImportToScene method of the wall_box object. This creates a box-shaped wall in the simulation. grav = netdem.Gravity() grav.Init(sim) sim.modifier_manager.Insert(grav) sim.modifier_manager.Enable(grav.label) Creates an instance of the Gravity class and assigns it to the variable grav . The Init method initializes the gravity object using the sim simulation object. The gravity object is then inserted into the modifier manager of the simulation and enabled. This ensures that gravity affects the particles in the simulation. data_dumper = netdem.DataDumper() data_dumper.Init(sim) data_dumper.SetRootPath(\"tmp/out/\") data_dumper.SetSaveByCycles(100) data_dumper.dump_contact_info = True data_dumper.dump_wall_info = True data_dumper.SaveShapeInfoAsSTL() sim.modifier_manager.Insert(data_dumper) sim.modifier_manager.Enable(data_dumper.label) Creates an instance of the DataDumper class and assigns it to the variable data_dumper . The Init method initializes the data dumper object using the sim simulation object. The following lines specify various settings for the data dumper, such as the root path for saving files (\"tmp/out/\"), the save frequency (every 100 cycles), and the types of data to be dumped (contact information and wall information). Additionally, the SaveShapeInfoAsSTL method is called to enable saving shape information as STL files. Finally, the data dumper object is inserted into the modifier manager of the simulation and enabled. for i in range(20): sim.scene.InsertParticle(particle_list) sim.Run(0.1) In a loop that iterates 20 times, particles from the particle_list are inserted into the simulation scene using the InsertParticle method. Then, the simulation is run for a duration of 0.1 time units using the Run method. This loop allows the particles to settle in the simulation before further simulation steps. sim.Run(2.0) Finally, the simulation is run for a duration of 2.0 time units using the Run method. This completes the simulation process.","title":"Step-by-step explaination"},{"location":"examples/random_packing/#simulation-result","text":"Example \u250a Previous \u250a Next","title":"Simulation result"},{"location":"examples/triaxial_compression/","text":"Under construction.","title":"Triaxial compression"},{"location":"gallery/animations/","text":"This page collects animations from various simulations based on NetDEM. Granular mixing of spheres. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Packing and compression of deformable particles, with particle deformation solved by finite element method and particle contacts solved by signed distance field approach. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Debris flow simulation with spheres and triangles (using contact-area-weighted contact forces). Note this example is intended to demonstrate the capability of NetDEM but have not been calibrated to reassemble a real debris flow. Dam break and waves strike onto irregular-shaped particle assembly, a demonstrative example of integrating with OpenFOAM for coupled CFD-DEM simulation. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction. Membrane tensiling and twisting, simulated with finite element and neo-hookean model.","title":"Animations"},{"location":"gallery/animations/#_1","text":"This page collects animations from various simulations based on NetDEM. Granular mixing of spheres. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Packing and compression of deformable particles, with particle deformation solved by finite element method and particle contacts solved by signed distance field approach. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Debris flow simulation with spheres and triangles (using contact-area-weighted contact forces). Note this example is intended to demonstrate the capability of NetDEM but have not been calibrated to reassemble a real debris flow. Dam break and waves strike onto irregular-shaped particle assembly, a demonstrative example of integrating with OpenFOAM for coupled CFD-DEM simulation. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction. Membrane tensiling and twisting, simulated with finite element and neo-hookean model.","title":""},{"location":"gallery/snapshots/","text":"Under construction.","title":"Snapshots"},{"location":"gallery/snapshots/#_1","text":"Under construction.","title":""}]}